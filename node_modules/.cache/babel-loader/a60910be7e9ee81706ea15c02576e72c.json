{"ast":null,"code":"import URL from 'url-parser-lite';\nimport querystring from 'querystring';\nimport fetch from 'cross-fetch';\nimport stringify from 'json-stable-stringify';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction contains(string, substring) {\n  return string.indexOf(substring) !== -1;\n}\n\nfunction isAppbase(url) {\n  return contains(url, 'scalr.api.appbase.io');\n}\n\nfunction btoa() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  var str = input;\n  var output = ''; // eslint-disable-next-line\n\n  for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1); // eslint-disable-line no-bitwise\n  output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise\n  ) {\n    charCode = str.charCodeAt(i += 3 / 4);\n\n    if (charCode > 0xff) {\n      throw new Error('\"btoa\" failed: The string to be encoded contains characters outside of the Latin1 range.');\n    }\n\n    block = block << 8 | charCode; // eslint-disable-line no-bitwise\n  }\n\n  return output;\n}\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0; // eslint-disable-line no-bitwise\n\n    var v = c === 'x' ? r : r & 0x3 | 0x8; // eslint-disable-line no-bitwise\n\n    return v.toString(16);\n  });\n}\n\nfunction validate(object, fields) {\n  var invalid = [];\n  var emptyFor = {\n    object: null,\n    string: ''\n  };\n  var keys = Object.keys(fields);\n  keys.forEach(function (key) {\n    var type = fields[key]; // eslint-disable-next-line\n\n    if (_typeof(object[key]) !== type || object[key] === emptyFor[type]) {\n      invalid.push(key);\n    }\n  });\n  var missing = '';\n\n  for (var i = 0; i < invalid.length; i += 1) {\n    missing += invalid[i] + ', ';\n  }\n\n  if (invalid.length > 0) {\n    return new Error('fields missing: ' + missing);\n  }\n\n  return true;\n}\n\nfunction removeUndefined(value) {\n  if (value || !(Object.keys(value).length === 0 && value.constructor === Object)) {\n    return JSON.parse(JSON.stringify(value));\n  }\n\n  return null;\n}\n/**\n * Send only when a connection is opened\n * @param {Object} socket\n * @param {Function} callback\n */\n\n\nfunction waitForSocketConnection(socket, callback) {\n  setTimeout(function () {\n    if (socket.readyState === 1) {\n      if (callback != null) {\n        callback();\n      }\n    } else {\n      waitForSocketConnection(socket, callback);\n    }\n  }, 5); // wait 5 ms for the connection...\n}\n/**\n * Returns an instance of Appbase client\n * @param {Object} config To configure properties\n * @param {String} config.url\n * @param {String} config.app\n * @param {String} config.credentials\n * @param {String} config.username\n * @param {String} config.password\n * A callback function which will be invoked before a fetch request made\n */\n\n\nfunction AppBase(config) {\n  var _URL = URL(config.url || ''),\n      _URL$auth = _URL.auth,\n      auth = _URL$auth === undefined ? null : _URL$auth,\n      _URL$host = _URL.host,\n      host = _URL$host === undefined ? '' : _URL$host,\n      _URL$path = _URL.path,\n      path = _URL$path === undefined ? '' : _URL$path,\n      _URL$protocol = _URL.protocol,\n      protocol = _URL$protocol === undefined ? '' : _URL$protocol;\n\n  var url = host + path; // Validate config and throw appropriate error\n\n  if (typeof url !== 'string' || url === '') {\n    throw new Error('URL not present in options.');\n  }\n\n  if (typeof config.app !== 'string' || config.app === '') {\n    throw new Error('App name is not present in options.');\n  }\n\n  if (typeof protocol !== 'string' || protocol === '') {\n    throw new Error('Protocol is not present in url. URL should be of the form https://scalr.api.appbase.io');\n  } // Parse url\n\n\n  if (url.slice(-1) === '/') {\n    url = url.slice(0, -1);\n  }\n\n  var credentials = auth || null;\n  /**\n   * Credentials can be provided as a part of the URL,\n   * as username, password args or as a credentials argument directly */\n\n  if (typeof config.credentials === 'string' && config.credentials !== '') {\n    // eslint-disable-next-line\n    credentials = config.credentials;\n  } else if (typeof config.username === 'string' && config.username !== '' && typeof config.password === 'string' && config.password !== '') {\n    credentials = config.username + ':' + config.password;\n  }\n\n  if (isAppbase(url) && credentials === null) {\n    throw new Error('Authentication information is not present. Did you add credentials?');\n  }\n\n  this.url = url;\n  this.protocol = protocol;\n  this.app = config.app;\n  this.credentials = credentials;\n  this.headers = {};\n}\n/**\n * To perform fetch request\n * @param {Object} args\n * @param {String} args.method\n * @param {String} args.path\n * @param {Object} args.params\n * @param {Object} args.body\n */\n\n\nfunction fetchRequest(args) {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    var parsedArgs = removeUndefined(args);\n\n    try {\n      var method = parsedArgs.method,\n          path = parsedArgs.path,\n          params = parsedArgs.params,\n          body = parsedArgs.body;\n      var bodyCopy = body;\n      var contentType = path.endsWith('msearch') || path.endsWith('bulk') ? 'application/x-ndjson' : 'application/json';\n      var headers = Object.assign({}, {\n        Accept: 'application/json',\n        'Content-Type': contentType\n      }, _this.headers);\n      var timestamp = Date.now();\n\n      if (_this.credentials) {\n        headers.Authorization = 'Basic ' + btoa(_this.credentials);\n      }\n\n      var requestOptions = {\n        method: method,\n        headers: headers\n      };\n\n      if (Array.isArray(bodyCopy)) {\n        var arrayBody = '';\n        bodyCopy.forEach(function (item) {\n          arrayBody += JSON.stringify(item);\n          arrayBody += '\\n';\n        });\n        bodyCopy = arrayBody;\n      } else {\n        bodyCopy = JSON.stringify(bodyCopy) || {};\n      }\n\n      if (Object.keys(bodyCopy).length !== 0) {\n        requestOptions.body = bodyCopy;\n      }\n\n      var finalRequest = requestOptions;\n\n      if (_this.transformRequest) {\n        finalRequest = _this.transformRequest(requestOptions);\n      }\n\n      var responseHeaders = {};\n      return fetch(_this.protocol + '://' + _this.url + '/' + _this.app + '/' + path + '?' + querystring.stringify(params), finalRequest).then(function (res) {\n        if (res.status >= 500) {\n          return reject(res);\n        }\n\n        responseHeaders = res.headers;\n        return res.json().then(function (data) {\n          if (res.status >= 400) {\n            return reject(res);\n          }\n\n          var response = Object.assign({}, data, {\n            _timestamp: timestamp,\n            _headers: responseHeaders\n          });\n          return resolve(response);\n        });\n      });\n    } catch (e) {\n      return reject(e);\n    }\n  });\n}\n\nvar WebSocket = typeof window !== 'undefined' ? window.WebSocket : require('ws');\n/**\n * To connect a web socket\n * @param {Object} args\n * @param {String} args.method\n * @param {String} args.path\n * @param {Object} args.params\n * @param {Object} args.body\n */\n\nfunction wsRequest(args, onData, onError, onClose) {\n  var _this = this;\n\n  try {\n    var parsedArgs = removeUndefined(args);\n    var method = parsedArgs.method,\n        path = parsedArgs.path,\n        params = parsedArgs.params;\n    var bodyCopy = args.body;\n\n    if (!bodyCopy || (typeof bodyCopy === 'undefined' ? 'undefined' : _typeof(bodyCopy)) !== 'object') {\n      bodyCopy = {};\n    }\n\n    var init = function init() {\n      _this.ws = new WebSocket('wss://' + _this.url + '/' + _this.app);\n      _this.id = uuidv4();\n      _this.request = {\n        id: _this.id,\n        path: _this.app + '/' + path + '?' + querystring.stringify(params),\n        method: method,\n        body: bodyCopy\n      };\n\n      if (_this.credentials) {\n        _this.request.authorization = 'Basic ' + btoa(_this.credentials);\n      }\n\n      _this.result = {};\n\n      _this.closeHandler = function () {\n        _this.wsClosed();\n      };\n\n      _this.errorHandler = function (err) {\n        _this.processError.apply(_this, [err]);\n      };\n\n      _this.messageHandler = function (message) {\n        var dataObj = JSON.parse(message.data);\n\n        if (dataObj.body && dataObj.body.status >= 400) {\n          _this.processError.apply(_this, [dataObj]);\n        } else {\n          _this.processMessage.apply(_this, [dataObj]);\n        }\n      };\n\n      _this.send = function (request) {\n        waitForSocketConnection(_this.ws, function () {\n          try {\n            _this.ws.send(JSON.stringify(request));\n          } catch (e) {\n            console.warn(e);\n          }\n        });\n      };\n\n      _this.ws.onmessage = _this.messageHandler;\n      _this.ws.onerror = _this.errorHandler;\n      _this.ws.onclose = _this.closeHandler;\n\n      _this.send(_this.request);\n\n      _this.result.stop = _this.stop;\n      _this.result.reconnect = _this.reconnect;\n      return _this.result;\n    };\n\n    this.wsClosed = function () {\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    this.stop = function () {\n      _this.ws.onmessage = undefined;\n      _this.ws.onclose = undefined;\n      _this.ws.onerror = undefined;\n\n      _this.wsClosed();\n\n      var unsubRequest = JSON.parse(JSON.stringify(_this.request));\n      unsubRequest.unsubscribe = true;\n\n      if (_this.unsubscribed !== true) {\n        _this.send(unsubRequest);\n      }\n\n      _this.unsubscribed = true;\n    };\n\n    this.reconnect = function () {\n      _this.stop();\n\n      return wsRequest(args, onData, onError, onClose);\n    };\n\n    this.processError = function (err) {\n      if (onError) {\n        onError(err);\n      } else {\n        console.warn(err);\n      }\n    };\n\n    this.processMessage = function (origDataObj) {\n      var dataObj = JSON.parse(JSON.stringify(origDataObj));\n\n      if (!dataObj.id && dataObj.message) {\n        if (onError) {\n          onError(dataObj);\n        }\n\n        return;\n      }\n\n      if (dataObj.id === _this.id) {\n        if (dataObj.message) {\n          delete dataObj.id;\n\n          if (onError) {\n            onError(dataObj);\n          }\n\n          return;\n        }\n\n        if (dataObj.query_id) {\n          _this.query_id = dataObj.query_id;\n        }\n\n        if (dataObj.channel) {\n          _this.channel = dataObj.channel;\n        }\n\n        if (dataObj.body && dataObj.body !== '') {\n          if (onData) {\n            onData(dataObj.body);\n          }\n        }\n\n        return;\n      }\n\n      if (!dataObj.id && dataObj.channel && dataObj.channel === _this.channel) {\n        if (onData) {\n          onData(dataObj.event);\n        }\n      }\n    };\n\n    return init();\n  } catch (e) {\n    if (onError) {\n      onError(e);\n    } else {\n      console.warn(e);\n    }\n\n    return null;\n  }\n}\n/**\n * Index Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n * @param {String} args.id\n */\n\n\nfunction indexApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    type: 'string',\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = parsedArgs.type,\n      id = parsedArgs.id,\n      body = parsedArgs.body;\n  delete parsedArgs.type;\n  delete parsedArgs.body;\n  delete parsedArgs.id;\n  var path = void 0;\n\n  if (id) {\n    path = type + '/' + encodeURIComponent(id);\n  } else {\n    path = type;\n  }\n\n  return this.performFetchRequest({\n    method: 'POST',\n    path: path,\n    params: parsedArgs,\n    body: body\n  });\n}\n/**\n * Get Service\n * @param {Object} args\n * @param {String} args.type\n * @param {String} args.id\n */\n\n\nfunction getApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    type: 'string',\n    id: 'string'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = parsedArgs.type,\n      id = parsedArgs.id;\n  delete parsedArgs.type;\n  delete parsedArgs.id;\n  var path = type + '/' + encodeURIComponent(id);\n  return this.performFetchRequest({\n    method: 'GET',\n    path: path,\n    params: parsedArgs\n  });\n}\n/**\n * Update Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n * @param {String} args.id\n */\n\n\nfunction updateApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    type: 'string',\n    id: 'string',\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = parsedArgs.type,\n      id = parsedArgs.id,\n      body = parsedArgs.body;\n  delete parsedArgs.type;\n  delete parsedArgs.id;\n  delete parsedArgs.body;\n  var path = type + '/' + encodeURIComponent(id) + '/_update';\n  return this.performFetchRequest({\n    method: 'POST',\n    path: path,\n    params: parsedArgs,\n    body: body\n  });\n}\n/**\n * Delete Service\n * @param {Object} args\n * @param {String} args.type\n * @param {String} args.id\n */\n\n\nfunction deleteApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    type: 'string',\n    id: 'string'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = parsedArgs.type,\n      id = parsedArgs.id;\n  delete parsedArgs.type;\n  delete parsedArgs.id;\n  var path = type + '/' + encodeURIComponent(id);\n  return this.performFetchRequest({\n    method: 'DELETE',\n    path: path,\n    params: parsedArgs\n  });\n}\n/**\n * Bulk Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n */\n\n\nfunction bulkApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = parsedArgs.type,\n      body = parsedArgs.body;\n  delete parsedArgs.type;\n  delete parsedArgs.body;\n  var path = void 0;\n\n  if (type) {\n    path = type + '/_bulk';\n  } else {\n    path = '/_bulk';\n  }\n\n  return this.performFetchRequest({\n    method: 'POST',\n    path: path,\n    params: parsedArgs,\n    body: body\n  });\n}\n/**\n * Search Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n */\n\n\nfunction searchApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = void 0;\n\n  if (Array.isArray(parsedArgs.type)) {\n    type = parsedArgs.type.join();\n  } else {\n    // eslint-disable-next-line\n    type = parsedArgs.type;\n  }\n\n  var body = parsedArgs.body;\n  delete parsedArgs.type;\n  delete parsedArgs.body;\n  var path = void 0;\n\n  if (type) {\n    path = type + '/_search';\n  } else {\n    path = '_search';\n  }\n\n  return this.performFetchRequest({\n    method: 'POST',\n    path: path,\n    params: parsedArgs,\n    body: body\n  });\n}\n/**\n * Msearch Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n */\n\n\nfunction msearchApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = void 0;\n\n  if (Array.isArray(parsedArgs.type)) {\n    type = parsedArgs.type.join();\n  } else {\n    type = parsedArgs.type;\n  }\n\n  var body = parsedArgs.body;\n  delete parsedArgs.type;\n  delete parsedArgs.body;\n  var path = void 0;\n\n  if (type) {\n    path = type + '/_msearch';\n  } else {\n    path = '_msearch';\n  }\n\n  return this.performFetchRequest({\n    method: 'POST',\n    path: path,\n    params: parsedArgs,\n    body: body\n  });\n}\n/**\n * Stream Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Boolean} args.stream\n * @param {String} args.id\n * @param {Function} onData\n * @param {Function} onError\n * @param {Function} onClose\n */\n\n\nfunction getStream(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    type: 'string',\n    id: 'string'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  var type = parsedArgs.type,\n      id = parsedArgs.id;\n  delete parsedArgs.type;\n  delete parsedArgs.id;\n  delete parsedArgs.stream;\n\n  if (parsedArgs.stream === true) {\n    parsedArgs.stream = 'true';\n  } else {\n    delete parsedArgs.stream;\n    parsedArgs.streamonly = 'true';\n  }\n\n  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n\n  return this.performWsRequest.apply(this, [{\n    method: 'GET',\n    path: type + '/' + encodeURIComponent(id),\n    params: parsedArgs\n  }].concat(rest));\n}\n/**\n * Search Stream\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n * @param {Boolean} args.stream\n * @param {Function} onData\n * @param {Function} onError\n * @param {Function} onClose\n */\n\n\nfunction searchStreamApi(args) {\n  var parsedArgs = removeUndefined(args); // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  if (parsedArgs.type === undefined || Array.isArray(parsedArgs.type) && parsedArgs.type.length === 0) {\n    throw new Error('Missing fields: type');\n  }\n\n  var type = void 0;\n\n  if (Array.isArray(parsedArgs.type)) {\n    type = parsedArgs.type.join();\n  } else {\n    type = parsedArgs.type;\n  }\n\n  var body = parsedArgs.body;\n  delete parsedArgs.type;\n  delete parsedArgs.body;\n  delete parsedArgs.stream;\n  parsedArgs.streamonly = 'true';\n\n  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n\n  return this.performWsRequest.apply(this, [{\n    method: 'POST',\n    path: type + '/_search',\n    params: parsedArgs,\n    body: body\n  }].concat(rest));\n}\n/**\n * Webhook Service\n * @param {Object} args\n * @param {String} args.type\n * @param {Object} args.body\n * @param {Object} webhook\n * @param {Function} onData\n * @param {Function} onError\n * @param {Function} onClose\n */\n\n\nfunction searchStreamToURLApi(args, webhook) {\n  for (var _len = arguments.length, rest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    rest[_key - 2] = arguments[_key];\n  }\n\n  var _this = this;\n\n  var parsedArgs = removeUndefined(args);\n  var bodyCopy = parsedArgs.body;\n  var type = void 0;\n  var typeString = void 0; // Validate arguments\n\n  var valid = validate(parsedArgs, {\n    body: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  if (parsedArgs.type === undefined || !(typeof parsedArgs.type === 'string' || Array.isArray(parsedArgs.type)) || parsedArgs.type === '' || parsedArgs.type.length === 0) {\n    throw new Error('fields missing: type');\n  }\n\n  valid = validate(parsedArgs.body, {\n    query: 'object'\n  });\n\n  if (valid !== true) {\n    throw valid;\n  }\n\n  if (Array.isArray(parsedArgs.type)) {\n    type = parsedArgs.type;\n    typeString = parsedArgs.type.join();\n  } else {\n    type = [parsedArgs.type];\n    typeString = parsedArgs.type;\n  }\n\n  var webhooks = [];\n  var _bodyCopy = bodyCopy,\n      query = _bodyCopy.query;\n\n  if (typeof webhook === 'string') {\n    var webHookObj = {};\n    webHookObj.url = webhook;\n    webHookObj.method = 'GET';\n    webhooks.push(webHookObj);\n  } else if (webhook.constructor === Array) {\n    webhooks = webhook;\n  } else if (webhook === Object(webhook)) {\n    webhooks.push(webhook);\n  } else {\n    throw new Error('fields missing: second argument(webhook) is necessary');\n  }\n\n  var populateBody = function populateBody() {\n    bodyCopy = {};\n    bodyCopy.webhooks = webhooks;\n    bodyCopy.query = query;\n    bodyCopy.type = type;\n  };\n\n  populateBody();\n  var encode64 = btoa(stringify(query));\n  var path = '.percolator/webhooks-0-' + typeString + '-0-' + encode64;\n\n  this.change = function () {\n    webhooks = [];\n\n    if (typeof parsedArgs === 'string') {\n      var webhook2 = {};\n      webhook2.url = parsedArgs;\n      webhook2.method = 'POST';\n      webhooks.push(webhook2);\n    } else if (parsedArgs.constructor === Array) {\n      webhooks = parsedArgs;\n    } else if (parsedArgs === Object(parsedArgs)) {\n      webhooks.push(parsedArgs);\n    } else {\n      throw new Error('fields missing: one of webhook or url fields is required');\n    }\n\n    populateBody();\n    return _this.performRequest('POST');\n  };\n\n  this.stop = function () {\n    bodyCopy = undefined;\n    return _this.performRequest('DELETE');\n  };\n\n  this.performRequest = function (method) {\n    var res = _this.performWsRequest.apply(_this, [{\n      method: method,\n      path: path,\n      body: bodyCopy\n    }].concat(rest));\n\n    res.change = _this.change;\n    res.stop = _this.stop;\n    return res;\n  };\n\n  return this.performRequest('POST');\n}\n/**\n * To get types\n */\n\n\nfunction getTypesService() {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    try {\n      return _this.performFetchRequest({\n        method: 'GET',\n        path: '_mapping'\n      }).then(function (data) {\n        var types = Object.keys(data[_this.app].mappings).filter(function (type) {\n          return type !== '_default_';\n        });\n        return resolve(types);\n      });\n    } catch (e) {\n      return reject(e);\n    }\n  });\n}\n/**\n * To get mappings\n */\n\n\nfunction getMappings() {\n  return this.performFetchRequest({\n    method: 'GET',\n    path: '_mapping'\n  });\n}\n\nfunction index(config) {\n  var client = new AppBase(config);\n  AppBase.prototype.performFetchRequest = fetchRequest;\n  AppBase.prototype.performWsRequest = wsRequest;\n  AppBase.prototype.index = indexApi;\n  AppBase.prototype.get = getApi;\n  AppBase.prototype.update = updateApi;\n  AppBase.prototype.delete = deleteApi;\n  AppBase.prototype.bulk = bulkApi;\n  AppBase.prototype.search = searchApi;\n  AppBase.prototype.msearch = msearchApi;\n  AppBase.prototype.getStream = getStream;\n  AppBase.prototype.searchStream = searchStreamApi;\n  AppBase.prototype.searchStreamToURL = searchStreamToURLApi;\n  AppBase.prototype.getTypes = getTypesService;\n  AppBase.prototype.getMappings = getMappings;\n\n  AppBase.prototype.setHeaders = function (headers) {\n    this.headers = headers;\n  };\n\n  if (typeof window !== 'undefined') {\n    window.Appbase = client;\n  }\n\n  return client;\n}\n\nexport default index;","map":null,"metadata":{},"sourceType":"module"}