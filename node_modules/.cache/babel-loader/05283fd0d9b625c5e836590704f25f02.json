{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactGoogleMaps = require('react-google-maps');\n\nvar _MarkerClusterer = require('react-google-maps/lib/components/addons/MarkerClusterer');\n\nvar _MarkerClusterer2 = _interopRequireDefault(_MarkerClusterer);\n\nvar _MarkerWithLabel = require('react-google-maps/lib/components/addons/MarkerWithLabel');\n\nvar _actions = require('@appbaseio/reactivecore/lib/actions');\n\nvar _helper = require('@appbaseio/reactivecore/lib/utils/helper');\n\nvar _types = require('@appbaseio/reactivecore/lib/utils/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nvar _Dropdown = require('@appbaseio/reactivesearch/lib/components/shared/Dropdown');\n\nvar _Dropdown2 = _interopRequireDefault(_Dropdown);\n\nvar _utils = require('@appbaseio/reactivesearch/lib/utils');\n\nvar _Pagination = require('@appbaseio/reactivesearch/lib/components/result/addons/Pagination');\n\nvar _Pagination2 = _interopRequireDefault(_Pagination);\n\nvar _FormControlList = require('@appbaseio/reactivesearch/lib/styles/FormControlList');\n\nvar _MapPin = require('./addons/styles/MapPin');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nvar Standard = require('./addons/styles/Standard');\n\nvar BlueEssence = require('./addons/styles/BlueEssence');\n\nvar BlueWater = require('./addons/styles/BlueWater');\n\nvar FlatMap = require('./addons/styles/FlatMap');\n\nvar LightMonochrome = require('./addons/styles/LightMonochrome');\n\nvar MidnightCommander = require('./addons/styles/MidnightCommander');\n\nvar UnsaturatedBrowns = require('./addons/styles/UnsaturatedBrowns');\n\nvar MAP_CENTER = {\n  lat: 37.7749,\n  lng: 122.4194\n};\nvar MapComponent = (0, _reactGoogleMaps.withGoogleMap)(function (props) {\n  var children = props.children,\n      onMapMounted = props.onMapMounted,\n      allProps = _objectWithoutProperties(props, ['children', 'onMapMounted']);\n\n  return _react2.default.createElement(_reactGoogleMaps.GoogleMap, _extends({\n    ref: onMapMounted\n  }, allProps), children);\n});\n\nfunction getPrecision(a) {\n  if (isNaN(a)) return 0; // eslint-disable-line\n\n  var e = 1;\n  var p = 0;\n\n  while (Math.round(a * e) / e !== a) {\n    e *= 10;\n    p += 1;\n  }\n\n  return p;\n}\n\nfunction withDistinctLat(loc, count) {\n  var length = getPrecision(loc.lat);\n  var noiseFactor = length >= 6 ? 4 : length - 2;\n  var suffix = 1 / Math.pow(10, noiseFactor) * count;\n\n  var location = _extends({}, loc, {\n    lat: parseFloat((loc.lat + suffix).toFixed(length))\n  });\n\n  return location;\n}\n\nvar ReactiveMap = function (_Component) {\n  _inherits(ReactiveMap, _Component);\n\n  function ReactiveMap(props) {\n    _classCallCheck(this, ReactiveMap);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.mapStyles = [{\n      label: 'Standard',\n      value: Standard\n    }, {\n      label: 'Blue Essence',\n      value: BlueEssence\n    }, {\n      label: 'Blue Water',\n      value: BlueWater\n    }, {\n      label: 'Flat Map',\n      value: FlatMap\n    }, {\n      label: 'Light Monochrome',\n      value: LightMonochrome\n    }, {\n      label: 'Midnight Commander',\n      value: MidnightCommander\n    }, {\n      label: 'Unsaturated Browns',\n      value: UnsaturatedBrowns\n    }];\n\n    var currentMapStyle = _this.mapStyles.find(function (style) {\n      return style.label === props.defaultMapStyle;\n    }) || _this.mapStyles[0];\n\n    _this.state = {\n      currentMapStyle: currentMapStyle,\n      from: props.currentPage * props.size || 0,\n      isLoading: false,\n      totalPages: 0,\n      currentPage: props.currentPage,\n      mapBoxBounds: null,\n      searchAsMove: props.searchAsMove,\n      zoom: props.defaultZoom,\n      openMarkers: {},\n      preserveCenter: false,\n      markerOnTop: null\n    };\n    _this.mapRef = null;\n    _this.internalComponent = props.componentId + '__internal';\n    props.setQueryListener(props.componentId, props.onQueryChange, null);\n    return _this;\n  }\n\n  ReactiveMap.prototype.componentDidMount = function componentDidMount() {\n    this.props.addComponent(this.internalComponent);\n    this.props.addComponent(this.props.componentId);\n\n    if (this.props.stream) {\n      this.props.setStreaming(this.props.componentId, true);\n    }\n\n    var options = (0, _helper.getQueryOptions)(this.props);\n    options.from = this.state.from;\n\n    if (this.props.sortBy) {\n      var _ref;\n\n      options.sort = [(_ref = {}, _ref[this.props.dataField] = {\n        order: this.props.sortBy\n      }, _ref)];\n    }\n\n    this.defaultQuery = null;\n\n    if (this.props.defaultQuery) {\n      this.defaultQuery = this.props.defaultQuery(); // Override sort query with defaultQuery's sort if defined\n\n      if (this.defaultQuery.sort) {\n        options.sort = this.defaultQuery.sort;\n      } // since we want defaultQuery to be executed anytime\n      // map component's query is being executed\n\n\n      var persistMapQuery = true; // no need to forceExecute because setReact() will capture the main query\n      // and execute the defaultQuery along with it\n\n      var forceExecute = false;\n      this.props.setMapData(this.props.componentId, this.defaultQuery.query, persistMapQuery, forceExecute);\n    } else {\n      // only apply geo-distance when defaultQuery prop is not set\n      var query = this.getGeoDistanceQuery();\n\n      if (query) {\n        // - only persist the map query if center prop is set\n        // - ideally, persist the map query if you want to keep executing it\n        //   whenever there is a change (due to subscription) in the component query\n        var _persistMapQuery = !!this.props.center; // - forceExecute will make sure that the component query + Map query gets executed\n        //   irrespective of the changes in the component query\n        // - forceExecute will only come into play when searchAsMove is true\n        // - kindly note that forceExecute may result in one additional network request\n        //   since it bypasses the gatekeeping\n\n\n        var _forceExecute = this.state.searchAsMove;\n        this.props.setMapData(this.props.componentId, query, _persistMapQuery, _forceExecute);\n      }\n    }\n\n    this.props.setQueryOptions(this.props.componentId, options, !(this.defaultQuery && this.defaultQuery.query));\n    this.setReact(this.props);\n  };\n\n  ReactiveMap.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.sortBy !== nextProps.sortBy || this.props.size !== nextProps.size || !(0, _helper.isEqual)(this.props.dataField, nextProps.dataField)) {\n      var options = (0, _helper.getQueryOptions)(nextProps);\n      options.from = 0;\n\n      if (nextProps.sortBy) {\n        var _ref2;\n\n        options.sort = [(_ref2 = {}, _ref2[nextProps.dataField] = {\n          order: nextProps.sortBy\n        }, _ref2)];\n      }\n\n      this.setState({\n        from: 0,\n        currentPage: 0\n      });\n      this.props.setQueryOptions(this.props.componentId, options, true);\n    }\n\n    if (!(0, _helper.isEqual)(this.props.center, nextProps.center)) {\n      var persistMapQuery = !!nextProps.center; // we need to forceExecute the query because the center has changed\n\n      var forceExecute = true;\n      this.props.setMapData(this.props.componentId, this.getGeoQuery(nextProps), persistMapQuery, forceExecute);\n    }\n\n    if (!(0, _helper.isEqual)(this.props.hits, nextProps.hits)) {\n      this.setState({\n        openMarkers: {}\n      });\n    }\n\n    if (nextProps.defaultQuery && !(0, _helper.isEqual)(nextProps.defaultQuery(), this.defaultQuery)) {\n      var _options = (0, _helper.getQueryOptions)(nextProps);\n\n      _options.from = this.state.from;\n      this.defaultQuery = nextProps.defaultQuery();\n      var _defaultQuery = this.defaultQuery,\n          sort = _defaultQuery.sort,\n          query = _defaultQuery.query;\n\n      if (sort) {\n        _options.sort = this.defaultQuery.sort;\n        nextProps.setQueryOptions(nextProps.componentId, _options, !query);\n      }\n\n      var _persistMapQuery2 = true;\n      var _forceExecute2 = true;\n      this.props.setMapData(this.props.componentId, query, _persistMapQuery2, _forceExecute2);\n    }\n\n    if (this.props.stream !== nextProps.stream) {\n      this.props.setStreaming(nextProps.componentId, nextProps.stream);\n    }\n\n    if (!(0, _helper.isEqual)(nextProps.react, this.props.react)) {\n      this.setReact(nextProps);\n    } // called when page is changed\n\n\n    if (this.props.pagination && this.state.isLoading) {\n      if (nextProps.onPageChange) {\n        nextProps.onPageChange();\n      }\n\n      this.setState({\n        isLoading: false\n      });\n    }\n\n    if (!nextProps.pagination && this.props.hits && nextProps.hits && (this.props.hits.length < nextProps.hits.length || nextProps.hits.length === nextProps.total)) {\n      this.setState({\n        isLoading: false\n      });\n    }\n\n    if (!nextProps.pagination && nextProps.hits && this.props.hits && nextProps.hits.length < this.props.hits.length) {\n      if (nextProps.onPageChange) {\n        nextProps.onPageChange();\n      }\n\n      this.setState({\n        from: 0,\n        isLoading: false\n      });\n    }\n\n    if (nextProps.pagination && nextProps.total !== this.props.total) {\n      this.setState({\n        totalPages: Math.ceil(nextProps.total / nextProps.size),\n        currentPage: this.props.total ? 0 : this.state.currentPage\n      });\n    }\n\n    if (this.props.searchAsMove !== nextProps.searchAsMove) {\n      this.setState({\n        searchAsMove: nextProps.searchAsMove\n      }); // no need to execute the map query since the component will\n      // get re-rendered and the new query will be automatically evaluated\n    }\n\n    if (this.props.defaultZoom !== nextProps.defaultZoom && !isNaN(nextProps.defaultZoom) // eslint-disable-line\n    && nextProps.defaultZoom) {\n      this.setState({\n        zoom: nextProps.defaultZoom\n      });\n    }\n\n    if (this.props.defaultMapStyle !== nextProps.defaultMapStyle) {\n      this.setState({\n        currentMapStyle: this.mapStyles.find(function (style) {\n          return style.label === nextProps.defaultMapStyle;\n        }) || this.mapStyles[0]\n      });\n    }\n  };\n\n  ReactiveMap.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    if (this.state.searchAsMove !== nextState.searchAsMove || this.state.markerOnTop !== nextState.markerOnTop || this.props.showMapStyles !== nextProps.showMapStyles || this.props.autoCenter !== nextProps.autoCenter || this.props.streamAutoCenter !== nextProps.streamAutoCenter || this.props.defaultZoom !== nextProps.defaultZoom || this.props.showMarkerClusters !== nextProps.showMarkerClusters || !(0, _helper.isEqual)(this.state.currentMapStyle, nextState.currentMapStyle) || !(0, _helper.isEqual)(this.state.openMarkers, nextState.openMarkers)) {\n      return true;\n    }\n\n    if ((0, _helper.isEqual)(this.props.hits, nextProps.hits) && (0, _helper.isEqual)(this.props.streamHits, nextProps.streamHits)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ReactiveMap.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.props.removeComponent(this.props.componentId);\n    this.props.removeComponent(this.internalComponent);\n  }; // getArrPosition = location => [location.lat, location.lon || location.lng];\n\n\n  ReactiveMap.prototype.parseLocation = function parseLocation(location) {\n    if (Array.isArray(location)) {\n      return {\n        lat: Number(location[0]),\n        lng: Number(location[1])\n      };\n    }\n\n    return {\n      lat: location ? Number(location.lat) : this.props.defaultCenter.lat,\n      lng: location ? Number(location.lon === undefined ? location.lng : location.lon) : this.props.defaultCenter.lng\n    };\n  };\n\n  ReactiveMap.prototype.render = function render() {\n    var style = {\n      width: '100%',\n      height: '100vh',\n      position: 'relative'\n    };\n    return _react2.default.createElement('div', {\n      style: _extends({}, style, this.props.style),\n      className: this.props.className\n    }, this.props.onAllData ? this.props.onAllData((0, _helper.parseHits)(this.props.hits), (0, _helper.parseHits)(this.props.streamHits), this.loadMore, this.renderMap, this.renderPagination) : this.renderMap());\n  };\n\n  return ReactiveMap;\n}(_react.Component);\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.setReact = function (props) {\n    var react = props.react;\n\n    if (react) {\n      var newReact = (0, _helper.pushToAndClause)(react, _this2.internalComponent);\n      props.watchComponent(props.componentId, newReact);\n    } else {\n      props.watchComponent(props.componentId, {\n        and: _this2.internalComponent\n      });\n    }\n  };\n\n  this.getHitsCenter = function (hits) {\n    var data = hits.map(function (hit) {\n      return hit[_this2.props.dataField];\n    });\n\n    if (data.length) {\n      var numCoords = data.length;\n      var X = 0.0;\n      var Y = 0.0;\n      var Z = 0.0;\n      data.forEach(function (location) {\n        if (location) {\n          var _lat = 0.0;\n          var _lng = 0.0;\n\n          if (Array.isArray(location)) {\n            _lat = location[0] * Math.PI / 180;\n            _lng = location[1] * Math.PI / 180;\n          } else {\n            _lat = location.lat * Math.PI / 180;\n            _lng = (location.lng !== undefined ? location.lng : location.lon) * Math.PI / 180;\n          }\n\n          var a = Math.cos(_lat) * Math.cos(_lng);\n          var b = Math.cos(_lat) * Math.sin(_lng);\n          var c = Math.sin(_lat);\n          X += a;\n          Y += b;\n          Z += c;\n        }\n      });\n      X /= numCoords;\n      Y /= numCoords;\n      Z /= numCoords;\n      var lng = Math.atan2(Y, X);\n      var hyp = Math.sqrt(X * X + Y * Y);\n      var lat = Math.atan2(Z, hyp);\n      var newX = lat * 180 / Math.PI;\n      var newY = lng * 180 / Math.PI;\n      return {\n        lat: newX,\n        lng: newY\n      };\n    }\n\n    return false;\n  };\n\n  this.getArrPosition = function (location) {\n    return {\n      lat: location.lat,\n      lon: location.lon || location.lng\n    };\n  };\n\n  this.getGeoDistanceQuery = function () {\n    var center = _this2.props.center || _this2.props.defaultCenter;\n\n    if (center && _this2.props.defaultRadius) {\n      var _geo_distance; // skips geo bounding box query on initial load\n\n\n      _this2.skipBoundingBox = true;\n      return {\n        geo_distance: (_geo_distance = {\n          distance: '' + _this2.props.defaultRadius + _this2.props.unit\n        }, _geo_distance[_this2.props.dataField] = _this2.getArrPosition(center), _geo_distance)\n      };\n    }\n\n    return null;\n  };\n\n  this.getGeoQuery = function () {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this2.props;\n    _this2.defaultQuery = props.defaultQuery ? props.defaultQuery() : null;\n\n    if (_this2.mapRef) {\n      var _geo_bounding_box;\n\n      var mapBounds = _this2.mapRef.getBounds();\n\n      var north = mapBounds.getNorthEast().lat();\n      var south = mapBounds.getSouthWest().lat();\n      var east = mapBounds.getNorthEast().lng();\n      var west = mapBounds.getSouthWest().lng();\n      var boundingBoxCoordinates = {\n        top_left: [west, north],\n        bottom_right: [east, south]\n      };\n\n      _this2.setState({\n        mapBoxBounds: boundingBoxCoordinates\n      });\n\n      var geoQuery = {\n        geo_bounding_box: (_geo_bounding_box = {}, _geo_bounding_box[_this2.props.dataField] = boundingBoxCoordinates, _geo_bounding_box)\n      };\n\n      if (_this2.defaultQuery) {\n        var query = _this2.defaultQuery.query;\n\n        if (query) {\n          // adds defaultQuery's query to geo-query\n          // to generate a map query\n          return {\n            must: [geoQuery, query]\n          };\n        }\n      }\n\n      return geoQuery;\n    } // return the defaultQuery (if set) or null when map query not available\n\n\n    return _this2.defaultQuery ? _this2.defaultQuery.query : null;\n  };\n\n  this.setGeoQuery = function () {\n    var executeUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // execute a new query on theinitial mount\n    // or whenever searchAsMove is true and the map is dragged\n\n    if (executeUpdate || !_this2.skipBoundingBox && !_this2.state.mapBoxBounds) {\n      _this2.defaultQuery = _this2.getGeoQuery();\n      var persistMapQuery = !!_this2.props.center;\n      var forceExecute = _this2.state.searchAsMove;\n\n      _this2.props.setMapData(_this2.props.componentId, _this2.defaultQuery, persistMapQuery, forceExecute);\n    }\n\n    _this2.skipBoundingBox = false;\n  };\n\n  this.loadMore = function () {\n    if (_this2.props.hits && !_this2.props.pagination && _this2.props.total !== _this2.props.hits.length) {\n      var value = _this2.state.from + _this2.props.size;\n      var options = (0, _helper.getQueryOptions)(_this2.props);\n\n      _this2.setState({\n        from: value,\n        isLoading: true\n      });\n\n      _this2.props.loadMore(_this2.props.componentId, _extends({}, options, {\n        from: value\n      }), true);\n    } else if (_this2.state.isLoading) {\n      _this2.setState({\n        isLoading: false\n      });\n    }\n  };\n\n  this.setPage = function (page) {\n    var value = _this2.props.size * page;\n    var options = (0, _helper.getQueryOptions)(_this2.props);\n    options.from = _this2.state.from;\n\n    _this2.setState({\n      from: value,\n      isLoading: true,\n      currentPage: page\n    });\n\n    _this2.props.loadMore(_this2.props.componentId, _extends({}, options, {\n      from: value\n    }), false);\n\n    if (_this2.props.URLParams) {\n      _this2.props.setPageURL(_this2.props.componentId + '-page', page + 1, _this2.props.componentId + '-page', false, true);\n    }\n  };\n\n  this.getPosition = function (result) {\n    if (result) {\n      return _this2.parseLocation(result[_this2.props.dataField]);\n    }\n\n    return null;\n  };\n\n  this.setMapStyle = function (currentMapStyle) {\n    _this2.setState({\n      currentMapStyle: currentMapStyle\n    });\n  };\n\n  this.getCenter = function (hits) {\n    if (_this2.props.center) {\n      return _this2.parseLocation(_this2.props.center);\n    }\n\n    if (!!_this2.mapRef && _this2.state.preserveCenter || _this2.props.stream && _this2.props.streamHits.length && !_this2.props.streamAutoCenter) {\n      var currentCenter = _this2.mapRef.getCenter();\n\n      setTimeout(function () {\n        _this2.setState({\n          preserveCenter: false\n        });\n      }, 100);\n      return _this2.parseLocation({\n        lat: currentCenter.lat(),\n        lng: currentCenter.lng()\n      });\n    }\n\n    if (hits && hits.length) {\n      if (_this2.props.autoCenter || _this2.props.streamAutoCenter) {\n        return _this2.getHitsCenter(hits) || _this2.getDefaultCenter();\n      }\n\n      return hits[0] && hits[0][_this2.props.dataField] ? _this2.getPosition(hits[0]) : _this2.getDefaultCenter();\n    }\n\n    return _this2.getDefaultCenter();\n  };\n\n  this.getDefaultCenter = function () {\n    if (_this2.props.defaultCenter) return _this2.parseLocation(_this2.props.defaultCenter);\n    return _this2.parseLocation(MAP_CENTER);\n  };\n\n  this.handleOnIdle = function () {\n    // only make the geo_bounding query if we have hits data\n    if (_this2.props.hits.length && _this2.state.searchAsMove) {\n      // always execute geo-bounds query when center is set\n      // to improve the specificity of search results\n      var executeUpdate = !!_this2.props.center;\n\n      _this2.setGeoQuery(executeUpdate);\n    }\n\n    if (_this2.props.mapProps.onIdle) _this2.props.mapProps.onIdle();\n  };\n\n  this.handleOnDragEnd = function () {\n    if (_this2.state.searchAsMove) {\n      _this2.setState({\n        preserveCenter: true\n      }, function () {\n        _this2.setGeoQuery(true);\n      });\n    }\n\n    if (_this2.props.mapProps.onDragEnd) _this2.props.mapProps.onDragEnd();\n  };\n\n  this.handleZoomChange = function () {\n    var zoom = _this2.mapRef.getZoom();\n\n    if (_this2.state.searchAsMove) {\n      _this2.setState({\n        zoom: zoom,\n        preserveCenter: true\n      }, function () {\n        _this2.setGeoQuery(true);\n      });\n    } else {\n      _this2.setState({\n        zoom: zoom\n      });\n    }\n\n    if (_this2.props.mapProps.onZoomChanged) _this2.props.mapProps.onZoomChanged();\n  };\n\n  this.toggleSearchAsMove = function () {\n    _this2.setState({\n      searchAsMove: !_this2.state.searchAsMove\n    });\n  };\n\n  this.renderSearchAsMove = function () {\n    if (_this2.props.showSearchAsMove) {\n      return _react2.default.createElement('div', {\n        style: {\n          position: 'absolute',\n          bottom: 30,\n          left: 10,\n          width: 240,\n          backgroundColor: '#fff',\n          padding: '8px 10px',\n          boxShadow: 'rgba(0,0,0,0.3) 0px 1px 4px -1px',\n          borderRadius: 2\n        },\n        className: (0, _helper.getClassName)(_this2.props.innerClass, 'checkboxContainer') || null\n      }, _react2.default.createElement(_FormControlList.Checkbox, {\n        className: (0, _helper.getClassName)(_this2.props.innerClass, 'checkbox') || null,\n        id: 'searchasmove',\n        onChange: _this2.toggleSearchAsMove,\n        checked: _this2.state.searchAsMove\n      }), _react2.default.createElement('label', {\n        className: (0, _helper.getClassName)(_this2.props.innerClass, 'label') || null,\n        htmlFor: 'searchasmove'\n      }, 'Search as I move the map'));\n    }\n\n    return null;\n  };\n\n  this.openMarkerInfo = function (id) {\n    var _ref3, _extends2;\n\n    var openMarkers = _this2.props.autoClosePopover ? (_ref3 = {}, _ref3[id] = true, _ref3) : _extends({}, _this2.state.openMarkers, (_extends2 = {}, _extends2[id] = true, _extends2));\n\n    _this2.setState({\n      openMarkers: openMarkers,\n      preserveCenter: true\n    });\n  };\n\n  this.closeMarkerInfo = function (id) {\n    var _state$openMarkers = _this2.state.openMarkers,\n        del = _state$openMarkers[id],\n        activeMarkers = _objectWithoutProperties(_state$openMarkers, [id]);\n\n    var openMarkers = _this2.props.autoClosePopover ? {} : activeMarkers;\n\n    _this2.setState({\n      openMarkers: openMarkers,\n      preserveCenter: true\n    });\n  };\n\n  this.renderPopover = function (item) {\n    var includeExternalSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var additionalProps = {};\n\n    if (includeExternalSettings) {\n      // to render pop-over correctly with MarkerWithLabel\n      additionalProps = {\n        position: _this2.getPosition(item),\n        defaultOptions: {\n          pixelOffset: new window.google.maps.Size(0, -30)\n        }\n      };\n    }\n\n    if (item._id in _this2.state.openMarkers) {\n      return _react2.default.createElement(_reactGoogleMaps.InfoWindow, _extends({\n        zIndex: 500,\n        key: item._id + '-InfoWindow',\n        onCloseClick: function onCloseClick() {\n          return _this2.closeMarkerInfo(item._id);\n        }\n      }, additionalProps), _this2.props.onPopoverClick(item));\n    }\n\n    return null;\n  };\n\n  this.increaseMarkerZIndex = function (id) {\n    _this2.setState({\n      markerOnTop: id,\n      preserveCenter: true\n    });\n  };\n\n  this.removeMarkerZIndex = function () {\n    _this2.setState({\n      markerOnTop: null,\n      preserveCenter: true\n    });\n  };\n\n  this.addNoise = function (hits) {\n    var hitMap = {};\n    var updatedHits = [];\n    hits.forEach(function (item) {\n      var updatedItem = _extends({}, item);\n\n      var location = _this2.parseLocation(item[_this2.props.dataField]);\n\n      var key = JSON.stringify(location);\n      var count = hitMap[key] || 0;\n      updatedItem[_this2.props.dataField] = count ? withDistinctLat(location, count) : location;\n      updatedHits = [].concat(updatedHits, [updatedItem]);\n      hitMap[key] = count + 1;\n    });\n    return updatedHits;\n  };\n\n  this.getMarkers = function (resultsToRender) {\n    var markers = [];\n\n    if (_this2.props.showMarkers) {\n      markers = resultsToRender.map(function (item) {\n        var markerProps = {\n          position: _this2.getPosition(item)\n        };\n\n        if (_this2.state.markerOnTop === item._id) {\n          markerProps.zIndex = window.google.maps.Marker.MAX_ZINDEX + 1;\n        }\n\n        if (_this2.props.onData) {\n          var data = _this2.props.onData(item);\n\n          if ('label' in data) {\n            return _react2.default.createElement(_MarkerWithLabel.MarkerWithLabel, _extends({\n              key: item._id,\n              labelAnchor: new window.google.maps.Point(0, 30),\n              icon: 'https://i.imgur.com/h81muef.png' // blank png to remove the icon\n              ,\n              onClick: function onClick() {\n                return _this2.openMarkerInfo(item._id);\n              },\n              onMouseOver: function onMouseOver() {\n                return _this2.increaseMarkerZIndex(item._id);\n              },\n              onFocus: function onFocus() {\n                return _this2.increaseMarkerZIndex(item._id);\n              },\n              onMouseOut: _this2.removeMarkerZIndex,\n              onBlur: _this2.removeMarkerZIndex\n            }, markerProps, _this2.props.markerProps), _react2.default.createElement('div', {\n              className: _MapPin.mapPinWrapper\n            }, _react2.default.createElement(_MapPin.MapPin, null, data.label), _react2.default.createElement(_MapPin.MapPinArrow, null), _this2.props.onPopoverClick ? _this2.renderPopover(item, true) : null));\n          } else if ('icon' in data) {\n            markerProps.icon = data.icon;\n          } else {\n            return _react2.default.createElement(_MarkerWithLabel.MarkerWithLabel, _extends({\n              key: item._id,\n              labelAnchor: new window.google.maps.Point(0, 0),\n              onMouseOver: function onMouseOver() {\n                return _this2.increaseMarkerZIndex(item._id);\n              },\n              onFocus: function onFocus() {\n                return _this2.increaseMarkerZIndex(item._id);\n              },\n              onMouseOut: _this2.removeMarkerZIndex,\n              onBlur: _this2.removeMarkerZIndex\n            }, markerProps, _this2.props.markerProps), data.custom);\n          }\n        } else if (_this2.props.defaultPin) {\n          markerProps.icon = _this2.props.defaultPin;\n        }\n\n        return _react2.default.createElement(_reactGoogleMaps.Marker, _extends({\n          key: item._id,\n          onClick: function onClick() {\n            return _this2.openMarkerInfo(item._id);\n          }\n        }, markerProps, _this2.props.markerProps), _this2.props.onPopoverClick ? _this2.renderPopover(item) : null);\n      });\n    }\n\n    return markers;\n  };\n\n  this.renderMap = function () {\n    var results = (0, _helper.parseHits)(_this2.props.hits) || [];\n    var streamResults = (0, _helper.parseHits)(_this2.props.streamHits) || [];\n    var filteredResults = results.filter(function (item) {\n      return !!item[_this2.props.dataField];\n    });\n\n    if (streamResults.length) {\n      var ids = streamResults.map(function (item) {\n        return item._id;\n      });\n      filteredResults = filteredResults.filter(function (item) {\n        return !ids.includes(item._id);\n      });\n    }\n\n    var resultsToRender = _this2.addNoise([].concat(streamResults, filteredResults));\n\n    var markers = _this2.getMarkers(resultsToRender);\n\n    var style = {\n      width: '100%',\n      height: '100%',\n      position: 'relative'\n    };\n    return _react2.default.createElement('div', {\n      style: style\n    }, _react2.default.createElement(MapComponent, _extends({\n      containerElement: _react2.default.createElement('div', {\n        style: style\n      }),\n      mapElement: _react2.default.createElement('div', {\n        style: {\n          height: '100%'\n        }\n      }),\n      onMapMounted: function onMapMounted(ref) {\n        _this2.mapRef = ref;\n\n        if (_this2.props.innerRef && ref) {\n          var map = Object.values(ref.context)[0];\n\n          var mapRef = _extends({}, ref, {\n            map: map\n          });\n\n          _this2.props.innerRef(mapRef);\n        }\n      },\n      zoom: _this2.state.zoom,\n      center: _this2.getCenter(resultsToRender)\n    }, _this2.props.mapProps, {\n      onIdle: _this2.handleOnIdle,\n      onZoomChanged: _this2.handleZoomChange,\n      onDragEnd: _this2.handleOnDragEnd,\n      options: _extends({\n        styles: _this2.state.currentMapStyle.value\n      }, (0, _helper.getInnerKey)(_this2.props.mapProps, 'options'))\n    }), _this2.props.showMarkers && _this2.props.showMarkerClusters ? _react2.default.createElement(_MarkerClusterer2.default, {\n      averageCenter: true,\n      enableRetinaIcons: true,\n      gridSize: 60\n    }, markers) : markers, _this2.props.showMarkers && _this2.props.markers, _this2.renderSearchAsMove()), _this2.props.showMapStyles ? _react2.default.createElement('div', {\n      style: {\n        position: 'absolute',\n        top: 10,\n        right: 46,\n        width: 120,\n        zIndex: window.google.maps.Marker.MAX_ZINDEX + 1\n      }\n    }, _react2.default.createElement(_Dropdown2.default, {\n      innerClass: _this2.props.innerClass,\n      items: _this2.mapStyles,\n      onChange: _this2.setMapStyle,\n      selectedItem: _this2.state.currentMapStyle,\n      keyField: 'label',\n      returnsObject: true,\n      small: true\n    })) : null);\n  };\n\n  this.renderPagination = function () {\n    return _react2.default.createElement(_Pagination2.default, {\n      pages: _this2.props.pages,\n      totalPages: _this2.state.totalPages,\n      currentPage: _this2.state.currentPage,\n      setPage: _this2.setPage,\n      innerClass: _this2.props.innerClass\n    });\n  };\n};\n\nReactiveMap.propTypes = {\n  addComponent: _types2.default.funcRequired,\n  setMapData: _types2.default.funcRequired,\n  loadMore: _types2.default.funcRequired,\n  removeComponent: _types2.default.funcRequired,\n  setQueryListener: _types2.default.funcRequired,\n  onQueryChange: _types2.default.func,\n  setPageURL: _types2.default.func,\n  setQueryOptions: _types2.default.funcRequired,\n  setStreaming: _types2.default.func,\n  updateQuery: _types2.default.funcRequired,\n  watchComponent: _types2.default.funcRequired,\n  currentPage: _types2.default.number,\n  hits: _types2.default.hits,\n  isLoading: _types2.default.bool,\n  streamHits: _types2.default.hits,\n  time: _types2.default.number,\n  total: _types2.default.number,\n  url: _types2.default.string,\n  // component props\n  autoCenter: _types2.default.bool,\n  center: _types2.default.location,\n  className: _types2.default.string,\n  componentId: _types2.default.stringRequired,\n  dataField: _types2.default.stringRequired,\n  defaultCenter: _types2.default.location,\n  defaultMapStyle: _types2.default.string,\n  defaultPin: _types2.default.string,\n  defaultQuery: _types2.default.func,\n  defaultZoom: _types2.default.number,\n  innerClass: _types2.default.style,\n  innerRef: _types2.default.func,\n  loader: _types2.default.title,\n  mapProps: _types2.default.props,\n  markerProps: _types2.default.props,\n  markers: _types2.default.children,\n  onAllData: _types2.default.func,\n  onData: _types2.default.func,\n  onPageChange: _types2.default.func,\n  onPopoverClick: _types2.default.func,\n  pages: _types2.default.number,\n  pagination: _types2.default.bool,\n  react: _types2.default.react,\n  searchAsMove: _types2.default.bool,\n  showMapStyles: _types2.default.bool,\n  showMarkerClusters: _types2.default.bool,\n  showMarkers: _types2.default.bool,\n  showSearchAsMove: _types2.default.bool,\n  size: _types2.default.number,\n  sortBy: _types2.default.sortBy,\n  stream: _types2.default.bool,\n  streamAutoCenter: _types2.default.bool,\n  style: _types2.default.style,\n  URLParams: _types2.default.bool,\n  defaultRadius: _types2.default.number,\n  unit: _types2.default.string,\n  autoClosePopover: _types2.default.bool\n};\nReactiveMap.defaultProps = {\n  size: 10,\n  style: {},\n  className: null,\n  pages: 5,\n  pagination: false,\n  defaultMapStyle: 'Standard',\n  autoCenter: false,\n  streamAutoCenter: false,\n  defaultZoom: 8,\n  mapProps: {},\n  markerProps: {},\n  markers: null,\n  showMapStyles: false,\n  showSearchAsMove: true,\n  searchAsMove: false,\n  showMarkers: true,\n  showMarkerClusters: true,\n  unit: 'mi',\n  defaultRadius: 100,\n  autoClosePopover: false\n};\n\nvar mapStateToProps = function mapStateToProps(state, props) {\n  return {\n    mapKey: state.config.mapKey,\n    hits: state.hits[props.componentId] && state.hits[props.componentId].hits || [],\n    streamHits: state.streamHits[props.componentId] || [],\n    currentPage: state.selectedValues[props.componentId + '-page'] && state.selectedValues[props.componentId + '-page'].value - 1 || 0,\n    time: state.hits[props.componentId] && state.hits[props.componentId].time || 0,\n    total: state.hits[props.componentId] && state.hits[props.componentId].total\n  };\n};\n\nvar mapDispatchtoProps = function mapDispatchtoProps(dispatch) {\n  return {\n    addComponent: function addComponent(component) {\n      return dispatch((0, _actions.addComponent)(component));\n    },\n    removeComponent: function removeComponent(component) {\n      return dispatch((0, _actions.removeComponent)(component));\n    },\n    setStreaming: function setStreaming(component, stream) {\n      return dispatch((0, _actions.setStreaming)(component, stream));\n    },\n    watchComponent: function watchComponent(component, react) {\n      return dispatch((0, _actions.watchComponent)(component, react));\n    },\n    setQueryOptions: function setQueryOptions(component, props, execute) {\n      return dispatch((0, _actions.setQueryOptions)(component, props, execute));\n    },\n    setQueryListener: function setQueryListener(component, onQueryChange, beforeQueryChange) {\n      return dispatch((0, _actions.setQueryListener)(component, onQueryChange, beforeQueryChange));\n    },\n    updateQuery: function updateQuery(updateQueryObject) {\n      return dispatch((0, _actions.updateQuery)(updateQueryObject));\n    },\n    loadMore: function loadMore(component, options, append) {\n      return dispatch((0, _actions.loadMore)(component, options, append));\n    },\n    setMapData: function setMapData(component, geoQuery, persistMapQuery) {\n      var forceExecute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      return dispatch((0, _actions.setMapData)(component, geoQuery, persistMapQuery, forceExecute));\n    }\n  };\n};\n\nexports.default = (0, _utils.connect)(mapStateToProps, mapDispatchtoProps)(ReactiveMap);","map":null,"metadata":{},"sourceType":"script"}