{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _actions = require('@appbaseio/reactivecore/lib/actions');\n\nvar _helper = require('@appbaseio/reactivecore/lib/utils/helper');\n\nvar _types = require('@appbaseio/reactivecore/lib/utils/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nvar _Pagination = require('./addons/Pagination');\n\nvar _Pagination2 = _interopRequireDefault(_Pagination);\n\nvar _PoweredBy = require('./addons/PoweredBy');\n\nvar _PoweredBy2 = _interopRequireDefault(_PoweredBy);\n\nvar _Flex = require('../../styles/Flex');\n\nvar _Flex2 = _interopRequireDefault(_Flex);\n\nvar _results = require('../../styles/results');\n\nvar _utils = require('../../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ReactiveList = function (_Component) {\n  _inherits(ReactiveList, _Component);\n\n  function ReactiveList(props) {\n    _classCallCheck(this, ReactiveList);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var currentPage = 0;\n\n    if (_this.props.defaultPage >= 0) {\n      currentPage = _this.props.defaultPage;\n    } else if (_this.props.currentPage) {\n      currentPage = Math.max(_this.props.currentPage - 1, 0);\n    }\n\n    _this.initialFrom = currentPage * props.size; // used for page resetting on query change\n\n    _this.state = {\n      from: _this.initialFrom,\n      isLoading: true,\n      currentPage: currentPage\n    };\n    _this.internalComponent = props.componentId + '__internal';\n    props.setQueryListener(props.componentId, props.onQueryChange, props.onError);\n    return _this;\n  }\n\n  ReactiveList.prototype.componentDidMount = function componentDidMount() {\n    this.props.addComponent(this.internalComponent);\n    this.props.addComponent(this.props.componentId);\n\n    if (this.props.stream) {\n      this.props.setStreaming(this.props.componentId, true);\n    }\n\n    var options = (0, _helper.getQueryOptions)(this.props);\n    options.from = this.state.from;\n\n    if (this.props.sortOptions) {\n      var _ref;\n\n      options.sort = [(_ref = {}, _ref[this.props.sortOptions[0].dataField] = {\n        order: this.props.sortOptions[0].sortBy\n      }, _ref)];\n    } else if (this.props.sortBy) {\n      var _ref2;\n\n      options.sort = [(_ref2 = {}, _ref2[this.props.dataField] = {\n        order: this.props.sortBy\n      }, _ref2)];\n    } // Override sort query with defaultQuery's sort if defined\n\n\n    this.defaultQuery = null;\n\n    if (this.props.defaultQuery) {\n      this.defaultQuery = this.props.defaultQuery();\n\n      if (this.defaultQuery.sort) {\n        options.sort = this.defaultQuery.sort;\n      }\n    }\n\n    var _ref3 = this.defaultQuery || {},\n        sort = _ref3.sort,\n        query = _objectWithoutProperties(_ref3, ['sort']); // execute is set to false at the time of mount\n    // to avoid firing (multiple) partial queries.\n    // Hence we are building the query in parts here\n    // and only executing it with setReact() at core\n\n\n    var execute = false;\n    this.props.setQueryOptions(this.props.componentId, options, execute);\n\n    if (this.defaultQuery) {\n      this.props.updateQuery({\n        componentId: this.internalComponent,\n        query: query\n      }, execute);\n    } else {\n      this.props.updateQuery({\n        componentId: this.internalComponent,\n        query: null\n      }, execute);\n    } // query will be executed here\n\n\n    this.setReact(this.props);\n    this.domNode = window;\n\n    if (!this.props.pagination) {\n      var scrollTarget = this.props.scrollTarget;\n\n      if (scrollTarget) {\n        this.domNode = document.getElementById(scrollTarget);\n      }\n\n      this.domNode.addEventListener('scroll', this.scrollHandler);\n    }\n  };\n\n  ReactiveList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    var totalPages = Math.ceil(nextProps.total / nextProps.size) || 0;\n\n    if (!(0, _helper.isEqual)(this.props.sortOptions, nextProps.sortOptions) || this.props.sortBy !== nextProps.sortBy || this.props.size !== nextProps.size || !(0, _helper.isEqual)(this.props.dataField, nextProps.dataField) || !(0, _helper.isEqual)(this.props.includeFields, nextProps.includeFields) || !(0, _helper.isEqual)(this.props.excludeFields, nextProps.excludeFields)) {\n      var options = (0, _helper.getQueryOptions)(nextProps);\n      options.from = this.state.from;\n\n      if (nextProps.sortOptions) {\n        var _ref4;\n\n        options.sort = [(_ref4 = {}, _ref4[nextProps.sortOptions[0].dataField] = {\n          order: nextProps.sortOptions[0].sortBy\n        }, _ref4)];\n      } else if (nextProps.sortBy) {\n        var _ref5;\n\n        options.sort = [(_ref5 = {}, _ref5[nextProps.dataField] = {\n          order: nextProps.sortBy\n        }, _ref5)];\n      }\n\n      this.props.setQueryOptions(this.props.componentId, options, true);\n    }\n\n    if (nextProps.defaultQuery && !(0, _helper.isEqual)(nextProps.defaultQuery(), this.defaultQuery)) {\n      var _options = (0, _helper.getQueryOptions)(nextProps);\n\n      _options.from = 0;\n      this.defaultQuery = nextProps.defaultQuery();\n\n      var _defaultQuery = this.defaultQuery,\n          sort = _defaultQuery.sort,\n          query = _objectWithoutProperties(_defaultQuery, ['sort']);\n\n      if (sort) {\n        _options.sort = this.defaultQuery.sort;\n        nextProps.setQueryOptions(nextProps.componentId, _options, !query);\n      }\n\n      this.props.updateQuery({\n        componentId: this.internalComponent,\n        query: query\n      }, true); // reset page because of query change\n\n      this.setState({\n        currentPage: 0,\n        from: 0\n      }, function () {\n        _this2.updatePageURL(0);\n      });\n    }\n\n    if (this.props.stream !== nextProps.stream) {\n      this.props.setStreaming(nextProps.componentId, nextProps.stream);\n    }\n\n    if (!(0, _helper.isEqual)(nextProps.react, this.props.react)) {\n      this.setReact(nextProps);\n    }\n\n    if (this.props.pagination) {\n      // called when page is changed\n      if (this.state.isLoading && (this.props.hits || nextProps.hits)) {\n        if (nextProps.onPageChange) {\n          nextProps.onPageChange(this.state.currentPage + 1, totalPages);\n        } else {\n          this.domNode.scrollTo(0, 0);\n        }\n\n        this.setState({\n          isLoading: false\n        });\n      }\n\n      if (this.props.currentPage !== nextProps.currentPage && nextProps.currentPage > 0 && nextProps.currentPage <= totalPages) {\n        this.setPage(nextProps.currentPage - 1);\n      }\n    }\n\n    if (!nextProps.pagination) {\n      if (this.props.hits && nextProps.hits) {\n        if (this.props.hits.length !== nextProps.hits.length || nextProps.hits.length === nextProps.total) {\n          this.setState({\n            isLoading: false\n          });\n\n          if (nextProps.hits.length < this.props.hits.length) {\n            // query has changed\n            this.domNode.scrollTo(0, 0);\n            this.setState({\n              from: 0\n            });\n          }\n        }\n      } else if ((!this.props.hits || !this.props.hits.length) && nextProps.hits) {\n        this.setState({\n          isLoading: false\n        });\n      }\n    }\n\n    if (nextProps.queryLog && this.props.queryLog && nextProps.queryLog !== this.props.queryLog) {\n      // usecase:\n      // - query has changed from non-null prev query\n      if (nextProps.queryLog.from !== this.state.from) {\n        // query's 'from' key doesn't match the state's 'from' key,\n        // i.e. this query change was not triggered by the page change (loadMore)\n        this.setState({\n          currentPage: 0\n        }, function () {\n          _this2.updatePageURL(0);\n        });\n\n        if (nextProps.onPageChange) {\n          nextProps.onPageChange(1, totalPages);\n        }\n      } else if (this.initialFrom && this.initialFrom === nextProps.queryLog.from) {\n        // [non-zero] initialFrom matches the current query's from\n        // but the query has changed\n        // we need to update the query options in this case\n        // because the initial load had set the query 'from' in the store\n        // which is not valid anymore because the query has changed\n        var _options2 = (0, _helper.getQueryOptions)(nextProps);\n\n        _options2.from = 0;\n        this.initialFrom = 0;\n\n        if (nextProps.sortOptions) {\n          var _ref6;\n\n          _options2.sort = [(_ref6 = {}, _ref6[nextProps.sortOptions[0].dataField] = {\n            order: nextProps.sortOptions[0].sortBy\n          }, _ref6)];\n        } else if (nextProps.sortBy) {\n          var _ref7;\n\n          _options2.sort = [(_ref7 = {}, _ref7[nextProps.dataField] = {\n            order: nextProps.sortBy\n          }, _ref7)];\n        }\n\n        this.props.setQueryOptions(this.props.componentId, _options2, true);\n      }\n    }\n\n    if (nextProps.pagination !== this.props.pagination) {\n      if (nextProps.pagination) {\n        this.domNode.addEventListener('scroll', this.scrollHandler);\n      } else {\n        this.domNode.removeEventListener('scroll', this.scrollHandler);\n      }\n    } // handle window url history change (on native back and forth interactions)\n\n\n    if (this.state.currentPage !== nextProps.defaultPage && this.props.defaultPage !== nextProps.defaultPage) {\n      this.setPage(nextProps.defaultPage >= 0 ? nextProps.defaultPage : 0);\n    }\n  };\n\n  ReactiveList.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.props.removeComponent(this.props.componentId);\n    this.props.removeComponent(this.internalComponent);\n\n    if (this.domNode) {\n      this.domNode.removeEventListener('scroll', this.scrollHandler);\n    }\n  }; // only used for SSR\n\n\n  ReactiveList.prototype.render = function render() {\n    var _this3 = this;\n\n    var _props = this.props,\n        onData = _props.onData,\n        size = _props.size;\n    var currentPage = this.state.currentPage;\n    var results = (0, _helper.parseHits)(this.props.hits) || [];\n    var streamResults = (0, _helper.parseHits)(this.props.streamHits) || [];\n    var filteredResults = results;\n\n    if (streamResults.length) {\n      var ids = streamResults.map(function (item) {\n        return item._id;\n      });\n      filteredResults = filteredResults.filter(function (item) {\n        return !ids.includes(item._id);\n      });\n    }\n\n    return _react2.default.createElement('div', {\n      style: this.props.style,\n      className: this.props.className\n    }, this.state.isLoading && this.props.pagination && this.props.loader, _react2.default.createElement(_Flex2.default, {\n      labelPosition: this.props.sortOptions ? 'right' : 'left',\n      className: (0, _helper.getClassName)(this.props.innerClass, 'resultsInfo')\n    }, this.props.sortOptions ? this.renderSortOptions() : null, this.props.showResultStats ? this.renderResultStats() : null), !this.state.isLoading && results.length === 0 && streamResults.length === 0 ? this.renderNoResults() : null, this.props.pagination && (this.props.paginationAt === 'top' || this.props.paginationAt === 'both') ? _react2.default.createElement(_Pagination2.default, {\n      pages: this.props.pages,\n      totalPages: Math.ceil(this.props.total / this.props.size),\n      currentPage: this.state.currentPage,\n      setPage: this.setPage,\n      innerClass: this.props.innerClass,\n      fragmentName: this.props.componentId\n    }) : null, this.props.onAllData ? this.props.onAllData(results, streamResults, this.loadMore, {\n      base: currentPage * size,\n      triggerClickAnalytics: this.triggerClickAnalytics\n    }) : _react2.default.createElement('div', {\n      className: this.props.listClass + ' ' + (0, _helper.getClassName)(this.props.innerClass, 'list')\n    }, [].concat(streamResults, filteredResults).map(function (item, index) {\n      return onData(item, function () {\n        return _this3.triggerClickAnalytics(currentPage * size + index);\n      });\n    })), this.state.isLoading && !this.props.pagination ? this.props.loader || _react2.default.createElement('div', {\n      style: {\n        textAlign: 'center',\n        margin: '20px 0',\n        color: '#666'\n      }\n    }, 'Loading...') : null, this.props.pagination && (this.props.paginationAt === 'bottom' || this.props.paginationAt === 'both') ? _react2.default.createElement(_Pagination2.default, {\n      pages: this.props.pages,\n      totalPages: Math.ceil(this.props.total / this.props.size),\n      currentPage: this.state.currentPage,\n      setPage: this.setPage,\n      innerClass: this.props.innerClass,\n      fragmentName: this.props.componentId\n    }) : null, this.props.config.url.endsWith('appbase.io') && results.length ? _react2.default.createElement(_Flex2.default, {\n      direction: 'row-reverse',\n      className: (0, _helper.getClassName)(this.props.innerClass, 'poweredBy')\n    }, _react2.default.createElement(_PoweredBy2.default, null)) : null);\n  };\n\n  return ReactiveList;\n}(_react.Component);\n\nReactiveList.generateQueryOptions = function (props) {\n  var options = {};\n  options.from = props.currentPage ? (props.currentPage - 1) * (props.size || 10) : 0;\n  options.size = props.size || 10;\n\n  if (props.sortOptions) {\n    var _ref8;\n\n    options.sort = [(_ref8 = {}, _ref8[props.sortOptions[0].dataField] = {\n      order: props.sortOptions[0].sortBy\n    }, _ref8)];\n  } else if (props.sortBy) {\n    var _ref9;\n\n    options.sort = [(_ref9 = {}, _ref9[props.dataField] = {\n      order: props.sortBy\n    }, _ref9)];\n  }\n\n  return options;\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this4 = this;\n\n  this.setReact = function (props) {\n    var react = props.react;\n\n    if (react) {\n      var newReact = (0, _helper.pushToAndClause)(react, _this4.internalComponent);\n      props.watchComponent(props.componentId, newReact);\n    } else {\n      props.watchComponent(props.componentId, {\n        and: _this4.internalComponent\n      });\n    }\n  };\n\n  this.scrollHandler = function () {\n    var renderLoader = window.innerHeight + window.pageYOffset + 300 >= document.body.offsetHeight;\n\n    if (_this4.props.scrollTarget) {\n      renderLoader = _this4.domNode.clientHeight + _this4.domNode.scrollTop + 300 >= _this4.domNode.scrollHeight;\n    }\n\n    if (!_this4.state.isLoading && renderLoader) {\n      _this4.loadMore();\n    }\n  };\n\n  this.loadMore = function () {\n    if (_this4.props.hits && !_this4.props.pagination && _this4.props.total !== _this4.props.hits.length) {\n      var value = _this4.state.from + _this4.props.size;\n      var options = (0, _helper.getQueryOptions)(_this4.props);\n\n      _this4.setState({\n        from: value,\n        isLoading: true\n      });\n\n      _this4.props.loadMore(_this4.props.componentId, _extends({}, options, {\n        from: value\n      }), true);\n    } else if (_this4.state.isLoading) {\n      _this4.setState({\n        isLoading: false\n      });\n    }\n  };\n\n  this.setPage = function (page) {\n    // onPageClick will be called everytime a pagination button is clicked\n    if (page !== _this4.state.currentPage) {\n      var onPageClick = _this4.props.onPageClick;\n\n      if (onPageClick) {\n        onPageClick(page + 1);\n      }\n\n      var value = _this4.props.size * page;\n      var options = (0, _helper.getQueryOptions)(_this4.props);\n      options.from = _this4.state.from;\n\n      _this4.setState({\n        from: value,\n        isLoading: true,\n        currentPage: page\n      }, function () {\n        _this4.props.loadMore(_this4.props.componentId, _extends({}, options, {\n          from: value\n        }), false);\n\n        _this4.updatePageURL(page);\n      });\n    }\n  };\n\n  this.renderResultStats = function () {\n    if (_this4.props.onResultStats && _this4.props.total) {\n      return _this4.props.onResultStats(_this4.props.total, _this4.props.time);\n    } else if (_this4.props.total) {\n      return _react2.default.createElement('p', {\n        className: _results.resultStats + ' ' + (0, _helper.getClassName)(_this4.props.innerClass, 'resultStats')\n      }, _this4.props.total, ' results found in ', _this4.props.time, 'ms');\n    }\n\n    return null;\n  };\n\n  this.renderNoResults = function () {\n    return _react2.default.createElement('p', {\n      className: (0, _helper.getClassName)(_this4.props.innerClass, 'noResults') || null\n    }, _this4.props.onNoResults);\n  };\n\n  this.handleSortChange = function (e) {\n    var _ref10;\n\n    var index = e.target.value;\n    var options = (0, _helper.getQueryOptions)(_this4.props); // This fixes issue #371 (where sorting a multi-result page with infinite loader breaks)\n\n    options.from = 0;\n    options.sort = [(_ref10 = {}, _ref10[_this4.props.sortOptions[index].dataField] = {\n      order: _this4.props.sortOptions[index].sortBy\n    }, _ref10)];\n\n    _this4.props.setQueryOptions(_this4.props.componentId, options, true);\n\n    _this4.setState({\n      currentPage: 0,\n      from: 0\n    }, function () {\n      _this4.updatePageURL(0);\n    });\n  };\n\n  this.updatePageURL = function (page) {\n    if (_this4.props.URLParams) {\n      _this4.props.setPageURL(_this4.props.componentId, page + 1, _this4.props.componentId, false, true);\n    }\n  };\n\n  this.triggerClickAnalytics = function (searchPosition) {\n    // click analytics would only work client side and after javascript loads\n    var _props2 = _this4.props,\n        config = _props2.config,\n        searchId = _props2.analytics.searchId;\n    var url = config.url,\n        app = config.app,\n        credentials = config.credentials;\n\n    if (config.analytics && url.endsWith('scalr.api.appbase.io') && searchId) {\n      fetch(url + '/' + app + '/analytics', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: 'Basic ' + btoa(credentials),\n          'X-Search-Id': searchId,\n          'X-Search-Click': true,\n          'X-Search-Click-Position': searchPosition + 1\n        }\n      });\n    }\n  };\n\n  this.renderSortOptions = function () {\n    return _react2.default.createElement('select', {\n      className: _results.sortOptions + ' ' + (0, _helper.getClassName)(_this4.props.innerClass, 'sortOptions'),\n      name: 'sort-options',\n      onChange: _this4.handleSortChange\n    }, _this4.props.sortOptions.map(function (sort, index) {\n      return _react2.default.createElement('option', {\n        key: sort.label,\n        value: index\n      }, sort.label);\n    }));\n  };\n};\n\nReactiveList.propTypes = {\n  addComponent: _types2.default.funcRequired,\n  loadMore: _types2.default.funcRequired,\n  removeComponent: _types2.default.funcRequired,\n  setQueryListener: _types2.default.funcRequired,\n  onQueryChange: _types2.default.func,\n  onError: _types2.default.func,\n  setPageURL: _types2.default.func,\n  setQueryOptions: _types2.default.funcRequired,\n  setStreaming: _types2.default.func,\n  updateQuery: _types2.default.funcRequired,\n  watchComponent: _types2.default.funcRequired,\n  currentPage: _types2.default.number,\n  hits: _types2.default.hits,\n  isLoading: _types2.default.bool,\n  includeFields: _types2.default.includeFields,\n  streamHits: _types2.default.hits,\n  time: _types2.default.number,\n  total: _types2.default.number,\n  config: _types2.default.props,\n  analytics: _types2.default.props,\n  queryLog: _types2.default.props,\n  // component props\n  className: _types2.default.string,\n  componentId: _types2.default.stringRequired,\n  dataField: _types2.default.stringRequired,\n  defaultPage: _types2.default.number,\n  defaultQuery: _types2.default.func,\n  excludeFields: _types2.default.excludeFields,\n  innerClass: _types2.default.style,\n  listClass: _types2.default.string,\n  loader: _types2.default.title,\n  onAllData: _types2.default.func,\n  onData: _types2.default.func,\n  onNoResults: _types2.default.title,\n  onPageChange: _types2.default.func,\n  onPageClick: _types2.default.func,\n  onResultStats: _types2.default.func,\n  pages: _types2.default.number,\n  pagination: _types2.default.bool,\n  paginationAt: _types2.default.paginationAt,\n  react: _types2.default.react,\n  scrollTarget: _types2.default.string,\n  showResultStats: _types2.default.bool,\n  size: _types2.default.number,\n  sortBy: _types2.default.sortBy,\n  sortOptions: _types2.default.sortOptions,\n  stream: _types2.default.bool,\n  style: _types2.default.style,\n  URLParams: _types2.default.bool\n};\nReactiveList.defaultProps = {\n  className: null,\n  currentPage: 0,\n  listClass: '',\n  pages: 5,\n  pagination: false,\n  paginationAt: 'bottom',\n  includeFields: ['*'],\n  excludeFields: [],\n  showResultStats: true,\n  size: 10,\n  style: {},\n  URLParams: false,\n  onNoResults: 'No Results found.'\n};\n\nvar mapStateToProps = function mapStateToProps(state, props) {\n  return {\n    defaultPage: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value - 1 || -1,\n    hits: state.hits[props.componentId] && state.hits[props.componentId].hits,\n    isLoading: state.isLoading[props.componentId] || false,\n    streamHits: state.streamHits[props.componentId],\n    time: state.hits[props.componentId] && state.hits[props.componentId].time || 0,\n    total: state.hits[props.componentId] && state.hits[props.componentId].total,\n    analytics: state.analytics,\n    config: state.config,\n    queryLog: state.queryLog[props.componentId]\n  };\n};\n\nvar mapDispatchtoProps = function mapDispatchtoProps(dispatch) {\n  return {\n    addComponent: function addComponent(component) {\n      return dispatch((0, _actions.addComponent)(component));\n    },\n    loadMore: function loadMore(component, options, append) {\n      return dispatch((0, _actions.loadMore)(component, options, append));\n    },\n    removeComponent: function removeComponent(component) {\n      return dispatch((0, _actions.removeComponent)(component));\n    },\n    setPageURL: function setPageURL(component, value, label, showFilter, URLParams) {\n      return dispatch((0, _actions.setValue)(component, value, label, showFilter, URLParams));\n    },\n    setQueryOptions: function setQueryOptions(component, props, execute) {\n      return dispatch((0, _actions.setQueryOptions)(component, props, execute));\n    },\n    setQueryListener: function setQueryListener(component, onQueryChange, beforeQueryChange) {\n      return dispatch((0, _actions.setQueryListener)(component, onQueryChange, beforeQueryChange));\n    },\n    setStreaming: function setStreaming(component, stream) {\n      return dispatch((0, _actions.setStreaming)(component, stream));\n    },\n    updateQuery: function updateQuery(updateQueryObject, execute) {\n      return dispatch((0, _actions.updateQuery)(updateQueryObject, execute));\n    },\n    watchComponent: function watchComponent(component, react) {\n      return dispatch((0, _actions.watchComponent)(component, react));\n    }\n  };\n};\n\nexports.default = (0, _utils.connect)(mapStateToProps, mapDispatchtoProps)(ReactiveList);","map":null,"metadata":{},"sourceType":"script"}