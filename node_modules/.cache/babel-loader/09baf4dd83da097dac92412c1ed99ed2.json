{"ast":null,"code":"/**\n * @preserve XDate v@VERSION\n * Docs & Licensing: http://arshaw.com/xdate/\n */\n\n/*\n * Internal Architecture\n * ---------------------\n * An XDate wraps a native Date. The native Date is stored in the '0' property of the object.\n * UTC-mode is determined by whether the internal native Date's toString method is set to\n * Date.prototype.toUTCString (see getUTCMode).\n *\n */\nvar XDate = function (Date, Math, Array, undefined) {\n  /** @const */\n  var FULLYEAR = 0;\n  /** @const */\n\n  var MONTH = 1;\n  /** @const */\n\n  var DATE = 2;\n  /** @const */\n\n  var HOURS = 3;\n  /** @const */\n\n  var MINUTES = 4;\n  /** @const */\n\n  var SECONDS = 5;\n  /** @const */\n\n  var MILLISECONDS = 6;\n  /** @const */\n\n  var DAY = 7;\n  /** @const */\n\n  var YEAR = 8;\n  /** @const */\n\n  var WEEK = 9;\n  /** @const */\n\n  var DAY_MS = 86400000;\n  var ISO_FORMAT_STRING = \"yyyy-MM-dd'T'HH:mm:ss(.fff)\";\n  var ISO_FORMAT_STRING_TZ = ISO_FORMAT_STRING + \"zzz\";\n  var methodSubjects = ['FullYear', // 0\n  'Month', // 1\n  'Date', // 2\n  'Hours', // 3\n  'Minutes', // 4\n  'Seconds', // 5\n  'Milliseconds', // 6\n  'Day', // 7\n  'Year' // 8\n  ];\n  var subjectPlurals = ['Years', // 0\n  'Months', // 1\n  'Days' // 2\n  ];\n  var unitsWithin = [12, // months in year\n  31, // days in month (sort of)\n  24, // hours in day\n  60, // minutes in hour\n  60, // seconds in minute\n  1000, // milliseconds in second\n  1 //\n  ];\n  var formatStringRE = new RegExp(\"(([a-zA-Z])\\\\2*)|\" + // 1, 2\n  \"(\\\\(\" + \"(('.*?'|\\\\(.*?\\\\)|.)*?)\" + \"\\\\))|\" + // 3, 4, 5 (allows for 1 level of inner quotes or parens)\n  \"('(.*?)')\" // 6, 7\n  );\n  var UTC = Date.UTC;\n  var toUTCString = Date.prototype.toUTCString;\n  var proto = XDate.prototype; // This makes an XDate look pretty in Firebug and Web Inspector.\n  // It makes an XDate seem array-like, and displays [ <internal-date>.toString() ]\n\n  proto.length = 1;\n  proto.splice = Array.prototype.splice;\n  /* Constructor\n  ---------------------------------------------------------------------------------*/\n  // TODO: in future, I'd change signature for the constructor regarding the `true` utc-mode param. ~ashaw\n  //   I'd move the boolean to be the *first* argument. Still optional. Seems cleaner.\n  //   I'd remove it from the `xdate`, `nativeDate`, and `milliseconds` constructors.\n  //      (because you can simply call .setUTCMode(true) after)\n  //   And I'd only leave it for the y/m/d/h/m/s/m and `dateString` constructors\n  //      (because those are the only constructors that need it for DST-gap data-loss reasons)\n  //   Should do this for 1.0\n\n  function XDate() {\n    return init(this instanceof XDate ? this : new XDate(), arguments);\n  }\n\n  function init(xdate, args) {\n    var len = args.length;\n    var utcMode;\n\n    if (isBoolean(args[len - 1])) {\n      utcMode = args[--len];\n      args = slice(args, 0, len);\n    }\n\n    if (!len) {\n      xdate[0] = new Date();\n    } else if (len == 1) {\n      var arg = args[0];\n\n      if (arg instanceof Date) {\n        xdate[0] = new Date(arg.getTime());\n      } else if (isNumber(arg)) {\n        xdate[0] = new Date(arg);\n      } else if (arg instanceof XDate) {\n        xdate[0] = _clone(arg);\n      } else if (isString(arg)) {\n        xdate[0] = new Date(0);\n        xdate = parse(arg, utcMode || false, xdate);\n      }\n    } else {\n      xdate[0] = new Date(UTC.apply(Date, args));\n\n      if (!utcMode) {\n        xdate[0] = coerceToLocal(xdate[0]);\n      }\n    }\n\n    if (isBoolean(utcMode)) {\n      setUTCMode(xdate, utcMode);\n    }\n\n    return xdate;\n  }\n  /* UTC Mode Methods\n  ---------------------------------------------------------------------------------*/\n\n\n  proto.getUTCMode = methodize(getUTCMode);\n\n  function getUTCMode(xdate) {\n    return xdate[0].toString === toUTCString;\n  }\n\n  ;\n  proto.setUTCMode = methodize(setUTCMode);\n\n  function setUTCMode(xdate, utcMode, doCoercion) {\n    if (utcMode) {\n      if (!getUTCMode(xdate)) {\n        if (doCoercion) {\n          xdate[0] = coerceToUTC(xdate[0]);\n        }\n\n        xdate[0].toString = toUTCString;\n      }\n    } else {\n      if (getUTCMode(xdate)) {\n        if (doCoercion) {\n          xdate[0] = coerceToLocal(xdate[0]);\n        } else {\n          xdate[0] = new Date(xdate[0].getTime());\n        } // toString will have been cleared\n\n      }\n    }\n\n    return xdate; // for chaining\n  }\n\n  proto.getTimezoneOffset = function () {\n    if (getUTCMode(this)) {\n      return 0;\n    } else {\n      return this[0].getTimezoneOffset();\n    }\n  };\n  /* get / set / add / diff Methods (except for week-related)\n  ---------------------------------------------------------------------------------*/\n\n\n  each(methodSubjects, function (subject, fieldIndex) {\n    proto['get' + subject] = function () {\n      return _getField(this[0], getUTCMode(this), fieldIndex);\n    };\n\n    if (fieldIndex != YEAR) {\n      // because there is no getUTCYear\n      proto['getUTC' + subject] = function () {\n        return _getField(this[0], true, fieldIndex);\n      };\n    }\n\n    if (fieldIndex != DAY) {\n      // because there is no setDay or setUTCDay\n      // and the add* and diff* methods use DATE instead\n      proto['set' + subject] = function (value) {\n        _set(this, fieldIndex, value, arguments, getUTCMode(this));\n\n        return this; // for chaining\n      };\n\n      if (fieldIndex != YEAR) {\n        // because there is no setUTCYear\n        // and the add* and diff* methods use FULLYEAR instead\n        proto['setUTC' + subject] = function (value) {\n          _set(this, fieldIndex, value, arguments, true);\n\n          return this; // for chaining\n        };\n\n        proto['add' + (subjectPlurals[fieldIndex] || subject)] = function (delta, preventOverflow) {\n          _add(this, fieldIndex, delta, preventOverflow);\n\n          return this; // for chaining\n        };\n\n        proto['diff' + (subjectPlurals[fieldIndex] || subject)] = function (otherDate) {\n          return _diff(this, otherDate, fieldIndex);\n        };\n      }\n    }\n  });\n\n  function _set(xdate, fieldIndex, value, args, useUTC) {\n    var getField = curry(_getField, xdate[0], useUTC);\n    var setField = curry(_setField, xdate[0], useUTC);\n    var expectedMonth;\n    var preventOverflow = false;\n\n    if (args.length == 2 && isBoolean(args[1])) {\n      preventOverflow = args[1];\n      args = [value];\n    }\n\n    if (fieldIndex == MONTH) {\n      expectedMonth = (value % 12 + 12) % 12;\n    } else {\n      expectedMonth = getField(MONTH);\n    }\n\n    setField(fieldIndex, args);\n\n    if (preventOverflow && getField(MONTH) != expectedMonth) {\n      setField(MONTH, [getField(MONTH) - 1]);\n      setField(DATE, [getDaysInMonth(getField(FULLYEAR), getField(MONTH))]);\n    }\n  }\n\n  function _add(xdate, fieldIndex, delta, preventOverflow) {\n    delta = Number(delta);\n    var intDelta = Math.floor(delta);\n    xdate['set' + methodSubjects[fieldIndex]](xdate['get' + methodSubjects[fieldIndex]]() + intDelta, preventOverflow || false);\n\n    if (intDelta != delta && fieldIndex < MILLISECONDS) {\n      _add(xdate, fieldIndex + 1, (delta - intDelta) * unitsWithin[fieldIndex], preventOverflow);\n    }\n  }\n\n  function _diff(xdate1, xdate2, fieldIndex) {\n    // fieldIndex=FULLYEAR is for years, fieldIndex=DATE is for days\n    xdate1 = xdate1.clone().setUTCMode(true, true);\n    xdate2 = XDate(xdate2).setUTCMode(true, true);\n    var v = 0;\n\n    if (fieldIndex == FULLYEAR || fieldIndex == MONTH) {\n      for (var i = MILLISECONDS, methodName; i >= fieldIndex; i--) {\n        v /= unitsWithin[i];\n        v += _getField(xdate2, false, i) - _getField(xdate1, false, i);\n      }\n\n      if (fieldIndex == MONTH) {\n        v += (xdate2.getFullYear() - xdate1.getFullYear()) * 12;\n      }\n    } else if (fieldIndex == DATE) {\n      var clear1 = xdate1.toDate().setUTCHours(0, 0, 0, 0); // returns an ms value\n\n      var clear2 = xdate2.toDate().setUTCHours(0, 0, 0, 0); // returns an ms value\n\n      v = Math.round((clear2 - clear1) / DAY_MS) + (xdate2 - clear2 - (xdate1 - clear1)) / DAY_MS;\n    } else {\n      v = (xdate2 - xdate1) / [3600000, // milliseconds in hour\n      60000, // milliseconds in minute\n      1000, // milliseconds in second\n      1 //\n      ][fieldIndex - 3];\n    }\n\n    return v;\n  }\n  /* Week Methods\n  ---------------------------------------------------------------------------------*/\n\n\n  proto.getWeek = function () {\n    return _getWeek(curry(_getField, this, false));\n  };\n\n  proto.getUTCWeek = function () {\n    return _getWeek(curry(_getField, this, true));\n  };\n\n  proto.setWeek = function (n, year) {\n    _setWeek(this, n, year, false);\n\n    return this; // for chaining\n  };\n\n  proto.setUTCWeek = function (n, year) {\n    _setWeek(this, n, year, true);\n\n    return this; // for chaining\n  };\n\n  proto.addWeeks = function (delta) {\n    return this.addDays(Number(delta) * 7);\n  };\n\n  proto.diffWeeks = function (otherDate) {\n    return _diff(this, otherDate, DATE) / 7;\n  };\n\n  function _getWeek(getField) {\n    return getWeek(getField(FULLYEAR), getField(MONTH), getField(DATE));\n  }\n\n  function getWeek(year, month, date) {\n    var d = new Date(UTC(year, month, date));\n    var week1 = getWeek1(getWeekYear(year, month, date));\n    return Math.floor(Math.round((d - week1) / DAY_MS) / 7) + 1;\n  }\n\n  function getWeekYear(year, month, date) {\n    // get the year that the date's week # belongs to\n    var d = new Date(UTC(year, month, date));\n\n    if (d < getWeek1(year)) {\n      return year - 1;\n    } else if (d >= getWeek1(year + 1)) {\n      return year + 1;\n    }\n\n    return year;\n  }\n\n  function getWeek1(year) {\n    // returns Date of first week of year, in UTC\n    var d = new Date(UTC(year, 0, 4));\n    d.setUTCDate(d.getUTCDate() - (d.getUTCDay() + 6) % 7); // make it Monday of the week\n\n    return d;\n  }\n\n  function _setWeek(xdate, n, year, useUTC) {\n    var getField = curry(_getField, xdate, useUTC);\n    var setField = curry(_setField, xdate, useUTC);\n\n    if (year === undefined) {\n      year = getWeekYear(getField(FULLYEAR), getField(MONTH), getField(DATE));\n    }\n\n    var week1 = getWeek1(year);\n\n    if (!useUTC) {\n      week1 = coerceToLocal(week1);\n    }\n\n    xdate.setTime(week1.getTime());\n    setField(DATE, [getField(DATE) + (n - 1) * 7]); // would have used xdate.addUTCWeeks :(\n    // n-1 because n is 1-based\n  }\n  /* Parsing\n  ---------------------------------------------------------------------------------*/\n\n\n  XDate.parsers = [parseISO];\n\n  XDate.parse = function (str) {\n    return +XDate('' + str);\n  };\n\n  function parse(str, utcMode, xdate) {\n    var parsers = XDate.parsers;\n    var i = 0;\n    var res;\n\n    for (; i < parsers.length; i++) {\n      res = parsers[i](str, utcMode, xdate);\n\n      if (res) {\n        return res;\n      }\n    }\n\n    xdate[0] = new Date(str);\n    return xdate;\n  }\n\n  function parseISO(str, utcMode, xdate) {\n    var m = str.match(/^(\\d{4})(-(\\d{2})(-(\\d{2})([T ](\\d{2}):(\\d{2})(:(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/);\n\n    if (m) {\n      var d = new Date(UTC(m[1], m[3] ? m[3] - 1 : 0, m[5] || 1, m[7] || 0, m[8] || 0, m[10] || 0, m[12] ? Number('0.' + m[12]) * 1000 : 0));\n\n      if (m[13]) {\n        // has gmt offset or Z\n        if (m[14]) {\n          // has gmt offset\n          d.setUTCMinutes(d.getUTCMinutes() + (m[15] == '-' ? 1 : -1) * (Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0)));\n        }\n      } else {\n        // no specified timezone\n        if (!utcMode) {\n          d = coerceToLocal(d);\n        }\n      }\n\n      return xdate.setTime(d.getTime());\n    }\n  }\n  /* Formatting\n  ---------------------------------------------------------------------------------*/\n\n\n  proto.toString = function (formatString, settings, uniqueness) {\n    if (formatString === undefined || !valid(this)) {\n      return this[0].toString(); // already accounts for utc-mode (might be toUTCString)\n    } else {\n      return format(this, formatString, settings, uniqueness, getUTCMode(this));\n    }\n  };\n\n  proto.toUTCString = proto.toGMTString = function (formatString, settings, uniqueness) {\n    if (formatString === undefined || !valid(this)) {\n      return this[0].toUTCString();\n    } else {\n      return format(this, formatString, settings, uniqueness, true);\n    }\n  };\n\n  proto.toISOString = function () {\n    return this.toUTCString(ISO_FORMAT_STRING_TZ);\n  };\n\n  XDate.defaultLocale = '';\n  XDate.locales = {\n    '': {\n      monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n      dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n      amDesignator: 'AM',\n      pmDesignator: 'PM'\n    }\n  };\n  XDate.formatters = {\n    i: ISO_FORMAT_STRING,\n    u: ISO_FORMAT_STRING_TZ\n  };\n\n  function format(xdate, formatString, settings, uniqueness, useUTC) {\n    var locales = XDate.locales;\n    var defaultLocaleSettings = locales[XDate.defaultLocale] || {};\n    var getField = curry(_getField, xdate, useUTC);\n    settings = (isString(settings) ? locales[settings] : settings) || {};\n\n    function getSetting(name) {\n      return settings[name] || defaultLocaleSettings[name];\n    }\n\n    function getFieldAndTrace(fieldIndex) {\n      if (uniqueness) {\n        var i = (fieldIndex == DAY ? DATE : fieldIndex) - 1;\n\n        for (; i >= 0; i--) {\n          uniqueness.push(getField(i));\n        }\n      }\n\n      return getField(fieldIndex);\n    }\n\n    return _format(xdate, formatString, getFieldAndTrace, getSetting, useUTC);\n  }\n\n  function _format(xdate, formatString, getField, getSetting, useUTC) {\n    var m;\n    var subout;\n    var out = '';\n\n    while (m = formatString.match(formatStringRE)) {\n      out += formatString.substr(0, m.index);\n\n      if (m[1]) {\n        // consecutive alphabetic characters\n        out += processTokenString(xdate, m[1], getField, getSetting, useUTC);\n      } else if (m[3]) {\n        // parenthesis\n        subout = _format(xdate, m[4], getField, getSetting, useUTC);\n\n        if (parseInt(subout.replace(/\\D/g, ''), 10)) {\n          // if any of the numbers are non-zero. or no numbers at all\n          out += subout;\n        }\n      } else {\n        // else if (m[6]) { // single quotes\n        out += m[7] || \"'\"; // if inner is blank, meaning 2 consecutive quotes = literal single quote\n      }\n\n      formatString = formatString.substr(m.index + m[0].length);\n    }\n\n    return out + formatString;\n  }\n\n  function processTokenString(xdate, tokenString, getField, getSetting, useUTC) {\n    var end = tokenString.length;\n    var replacement;\n    var out = '';\n\n    while (end > 0) {\n      replacement = getTokenReplacement(xdate, tokenString.substr(0, end), getField, getSetting, useUTC);\n\n      if (replacement !== undefined) {\n        out += replacement;\n        tokenString = tokenString.substr(end);\n        end = tokenString.length;\n      } else {\n        end--;\n      }\n    }\n\n    return out + tokenString;\n  }\n\n  function getTokenReplacement(xdate, token, getField, getSetting, useUTC) {\n    var formatter = XDate.formatters[token];\n\n    if (isString(formatter)) {\n      return _format(xdate, formatter, getField, getSetting, useUTC);\n    } else if (isFunction(formatter)) {\n      return formatter(xdate, useUTC || false, getSetting);\n    }\n\n    switch (token) {\n      case 'fff':\n        return zeroPad(getField(MILLISECONDS), 3);\n\n      case 's':\n        return getField(SECONDS);\n\n      case 'ss':\n        return zeroPad(getField(SECONDS));\n\n      case 'm':\n        return getField(MINUTES);\n\n      case 'mm':\n        return zeroPad(getField(MINUTES));\n\n      case 'h':\n        return getField(HOURS) % 12 || 12;\n\n      case 'hh':\n        return zeroPad(getField(HOURS) % 12 || 12);\n\n      case 'H':\n        return getField(HOURS);\n\n      case 'HH':\n        return zeroPad(getField(HOURS));\n\n      case 'd':\n        return getField(DATE);\n\n      case 'dd':\n        return zeroPad(getField(DATE));\n\n      case 'ddd':\n        return getSetting('dayNamesShort')[getField(DAY)] || '';\n\n      case 'dddd':\n        return getSetting('dayNames')[getField(DAY)] || '';\n\n      case 'M':\n        return getField(MONTH) + 1;\n\n      case 'MM':\n        return zeroPad(getField(MONTH) + 1);\n\n      case 'MMM':\n        return getSetting('monthNamesShort')[getField(MONTH)] || '';\n\n      case 'MMMM':\n        return getSetting('monthNames')[getField(MONTH)] || '';\n\n      case 'yy':\n        return (getField(FULLYEAR) + '').substring(2);\n\n      case 'yyyy':\n        return getField(FULLYEAR);\n\n      case 't':\n        return _getDesignator(getField, getSetting).substr(0, 1).toLowerCase();\n\n      case 'tt':\n        return _getDesignator(getField, getSetting).toLowerCase();\n\n      case 'T':\n        return _getDesignator(getField, getSetting).substr(0, 1);\n\n      case 'TT':\n        return _getDesignator(getField, getSetting);\n\n      case 'z':\n      case 'zz':\n      case 'zzz':\n        return useUTC ? 'Z' : _getTZString(xdate, token);\n\n      case 'w':\n        return _getWeek(getField);\n\n      case 'ww':\n        return zeroPad(_getWeek(getField));\n\n      case 'S':\n        var d = getField(DATE);\n        if (d > 10 && d < 20) return 'th';\n        return ['st', 'nd', 'rd'][d % 10 - 1] || 'th';\n    }\n  }\n\n  function _getTZString(xdate, token) {\n    var tzo = xdate.getTimezoneOffset();\n    var sign = tzo < 0 ? '+' : '-';\n    var hours = Math.floor(Math.abs(tzo) / 60);\n    var minutes = Math.abs(tzo) % 60;\n    var out = hours;\n\n    if (token == 'zz') {\n      out = zeroPad(hours);\n    } else if (token == 'zzz') {\n      out = zeroPad(hours) + ':' + zeroPad(minutes);\n    }\n\n    return sign + out;\n  }\n\n  function _getDesignator(getField, getSetting) {\n    return getField(HOURS) < 12 ? getSetting('amDesignator') : getSetting('pmDesignator');\n  }\n  /* Misc Methods\n  ---------------------------------------------------------------------------------*/\n\n\n  each([// other getters\n  'getTime', 'valueOf', 'toDateString', 'toTimeString', 'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString', 'toJSON'], function (methodName) {\n    proto[methodName] = function () {\n      return this[0][methodName]();\n    };\n  });\n\n  proto.setTime = function (t) {\n    this[0].setTime(t);\n    return this; // for chaining\n  };\n\n  proto.valid = methodize(valid);\n\n  function valid(xdate) {\n    return !isNaN(xdate[0].getTime());\n  }\n\n  proto.clone = function () {\n    return new XDate(this);\n  };\n\n  proto.clearTime = function () {\n    return this.setHours(0, 0, 0, 0); // will return an XDate for chaining\n  };\n\n  proto.toDate = function () {\n    return new Date(this[0].getTime());\n  };\n  /* Misc Class Methods\n  ---------------------------------------------------------------------------------*/\n\n\n  XDate.now = function () {\n    return new Date().getTime();\n  };\n\n  XDate.today = function () {\n    return new XDate().clearTime();\n  };\n\n  XDate.UTC = UTC;\n  XDate.getDaysInMonth = getDaysInMonth;\n  /* Internal Utilities\n  ---------------------------------------------------------------------------------*/\n\n  function _clone(xdate) {\n    // returns the internal Date object that should be used\n    var d = new Date(xdate[0].getTime());\n\n    if (getUTCMode(xdate)) {\n      d.toString = toUTCString;\n    }\n\n    return d;\n  }\n\n  function _getField(d, useUTC, fieldIndex) {\n    return d['get' + (useUTC ? 'UTC' : '') + methodSubjects[fieldIndex]]();\n  }\n\n  function _setField(d, useUTC, fieldIndex, args) {\n    d['set' + (useUTC ? 'UTC' : '') + methodSubjects[fieldIndex]].apply(d, args);\n  }\n  /* Date Math Utilities\n  ---------------------------------------------------------------------------------*/\n\n\n  function coerceToUTC(date) {\n    return new Date(UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n  }\n\n  function coerceToLocal(date) {\n    return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n  }\n\n  function getDaysInMonth(year, month) {\n    return 32 - new Date(UTC(year, month, 32)).getUTCDate();\n  }\n  /* General Utilities\n  ---------------------------------------------------------------------------------*/\n\n\n  function methodize(f) {\n    return function () {\n      return f.apply(undefined, [this].concat(slice(arguments)));\n    };\n  }\n\n  function curry(f) {\n    var firstArgs = slice(arguments, 1);\n    return function () {\n      return f.apply(undefined, firstArgs.concat(slice(arguments)));\n    };\n  }\n\n  function slice(a, start, end) {\n    return Array.prototype.slice.call(a, start || 0, // start and end cannot be undefined for IE\n    end === undefined ? a.length : end);\n  }\n\n  function each(a, f) {\n    for (var i = 0; i < a.length; i++) {\n      f(a[i], i);\n    }\n\n    ;\n  }\n\n  function isString(arg) {\n    return typeof arg == 'string';\n  }\n\n  function isNumber(arg) {\n    return typeof arg == 'number';\n  }\n\n  function isBoolean(arg) {\n    return typeof arg == 'boolean';\n  }\n\n  function isFunction(arg) {\n    return typeof arg == 'function';\n  }\n\n  function zeroPad(n, len) {\n    len = len || 2;\n    n += '';\n\n    while (n.length < len) {\n      n = '0' + n;\n    }\n\n    return n;\n  } // Export for Node.js\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = XDate;\n  } // AMD\n\n\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return XDate;\n    });\n  }\n\n  return XDate;\n}(Date, Math, Array);","map":null,"metadata":{},"sourceType":"script"}